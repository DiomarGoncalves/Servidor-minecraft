import{Block as v,BlockVolume as A,ListBlockVolume as F}from"@minecraft/server";import{assertCanBuildWithin as H}from"server/modules/assert.js";import{Mask as x}from"server/modules/mask.js";import{regionIterateBlocks as P,regionIterateChunks as I,regionVolume as G,Vector as g}from"library/Minecraft.js";import{getWorldHeightLimits as O,snap as T}from"../util.js";import{Jobs as l}from"server/modules/jobs.js";var C=(o=>(o[o.EMPTY=0]="EMPTY",o[o.FULL=1]="FULL",o[o.DETAIL=2]="DETAIL",o))(C||{});class R{constructor(){this.usedInBrush=!1}getChunkStatus(n,t,o){return 2}draw(n,t,o=!1){try{for(const[e,i]of this.outlineCache=this.outlineCache??this.getOutline())try{(o?n:n.dimension).spawnParticle(e,i.add(t))}catch{}}catch{}}*getBlocks(n,t){const o=this.getRegion(n);this.genVars={},this.prepGeneration(this.genVars,t);for(const e of P(...o))this.inShape(g.sub(e,n).floor(),this.genVars)&&(yield e)}inShapeHollow(n,t){const o=this.inShape(n,t);if(t.hollow&&o){const e=t.hollowThickness??1;let i=0;for(const r of[[0,e,0],[0,-e,0],[e,0,0],[-e,0,0],[0,0,e],[0,0,-e]])i+=this.inShape(n.add(r),t)?1:0;return i==6?!1:o}else return o}drawLine(n,t=!1,o=!1){const e=n.map((i,r)=>[r,(r+1)%n.length]);return t||e.splice(e.length-1,1),this.drawShape(n,e,o)}drawShape(n,t,o=!1){const e=[];if(!o)for(const i of t){const[r,s]=[n[i[0]],n[i[1]]],c=Math.min(Math.floor(s.sub(r).length),16);for(let m=1;m<c;m++){const b=m/c;e.push(r.lerp(s,b))}}return n.concat(e).map(i=>["wedit:selection_draw",i])}drawCircle(n,t,o){const e=o==="x"?new g(0,1,0):o==="y"?new g(1,0,0):new g(0,1,0),i=T(Math.min(t*2*Math.PI,36),4),r=[];for(let s=0;s<i;s++){let c=e.rotate(s/i*360,o);c=c.mul(t).add(n).add(.5),r.push(["wedit:selection_draw",c])}return r}inShape(n,t){return!1}*calculateShape(n,t,o,e,i,r){let s=0,c=0;const m=[],b=i.isSimple(),V=r.isSimple(),y=G(o,e),f=this.customHollow?"inShape":"inShapeHollow";for(const[d,h]of I(o,e)){yield l.setProgress(s/y);const p=this.getChunkStatus(g.sub(d,t).floor(),g.sub(h,t).floor(),this.genVars);if(p===1&&V){const a=G(d,h);s+=a,c+=a,m.push(new A(d,h))}else if(p===0){const a=G(d,h);s+=a}else{const a=[];for(const k of P(d,h)){if(yield l.setProgress(s/y),s++,this[f](g.sub(k,t).floor(),this.genVars)){const w=n.getBlock(k)??(yield*l.loadBlock(k));(V||r.matchesBlock(w))&&(a.push(w),c++)}yield}a.length&&m.push(b?new F(a):a)}}return[m,c]}*generate(n,t,o,e,i){const[r,s]=this.getRegion(n),c=e.player,m=c.dimension,[b,V]=O(m);r.y=Math.max(b,r.y),s.y=Math.min(V,s.y);const y=s.y>=r.y;t=t.withContext(e,[r,s]),l.inContext()||H(c,r,s);const f=i?.recordHistory??!0?e.history:void 0,d=f?.record();if(!y)return f?.commit(d),yield l.nextStep("Calculating shape..."),yield l.nextStep("Generating blocks..."),0;try{let h=0;this.genVars={},this.prepGeneration(this.genVars,i);let p=o??new x;const a=i?.ignoreGlobalMask??!1?new x:e.globalMask;p=(p?a?p.intersect(a):p:a)?.withContext(e);const k=p.isSimple();yield l.nextStep("Calculating shape...");const[w,L]=yield*this.calculateShape(m,n,r,s,t,p);let B=0;yield l.nextStep("Generating blocks..."),f&&(yield*f.trackRegion(d,r,s));const M=k?p:void 0;for(let u of w)if(yield l.setProgress(B/L),Array.isArray(u))for(let S of u)!S.isValid&&l.inContext()&&(S=yield*l.loadBlock(n)),(!M||M.matchesBlock(S))&&t.setBlock(S)&&h++,B++;else u instanceof v?(!u.isValid&&l.inContext()&&(u=yield*l.loadBlock(u)),(!p||p.matchesBlock(u))&&t.setBlock(u)&&h++,B++):(l.inContext()&&(yield*l.loadArea(u.getMin(),u.getMax())),h+=t.fillBlocks(m,u,M),B+=u.getCapacity());return f&&(yield*f.commit(d)),h}catch(h){throw f?.cancel(d),h}}}R.ChunkStatus=C;export{R as Shape};
