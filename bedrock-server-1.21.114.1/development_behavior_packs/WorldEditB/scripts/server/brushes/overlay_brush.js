import{Server as y,Vector as m,regionIterateBlocks as M}from"library/Minecraft.js";import{brushTypes as S,Brush as B}from"./base_brush.js";import{Mask as b}from"server/modules/mask.js";import{getWorldHeightLimits as w}from"server/util.js";import{Pattern as P}from"server/modules/pattern.js";import{recordBlockChanges as v}from"server/modules/block_changes.js";import{CylinderShape as O}from"server/shapes/cylinder.js";class V extends B{constructor(t,r,e,c){super();this.id="overlay_brush";this.assertSizeInRange(t),this.pattern=e,this.radius=t,this.depth=r,this.surfaceMask=c??new b}resize(t){this.assertSizeInRange(t),this.radius=t}getSize(){return this.radius}getDepth(){return this.depth}paintWith(t){this.pattern=t}getPattern(){return this.pattern}*apply(t,r,e){const c=[t.offset(-this.radius,1,-this.radius),t.offset(this.radius,1,this.radius)],f=w(r.player.dimension)[0],u=(e?r.globalMask?e.intersect(r.globalMask):e:r.globalMask)?.withContext(r),k=this.surfaceMask.withContext(r),p=y.block.isAirOrFluid,g=Math.pow(this.radius+.5,2),n=r.history,h=n.record(),s=v(r,h);try{for(const i of M(...c)){if(t.sub(i).lengthSqr>g||!p(s.getBlockPerm(i)))continue;const a=m.sub(i,[0,1,0]);for(;a.y>=f;){const l=s.getBlock(a);if(!p(l.permutation)&&k.matchesBlock(l)){for(let o=0;o<Math.abs(this.depth);o++){const d=s.getBlock(a.offset(0,this.depth>0?-o:o+1,0));(!u||u.matchesBlock(d))&&this.pattern.setBlock(d)}break}a.y--}yield}yield*s.flush(),yield*n.commit(h)}catch(i){throw n.cancel(h),i}}getOutline(){return[new O(1,this.radius),m.ZERO]}toJSON(){return{id:this.id,radius:this.radius,depth:this.depth,pattern:this.pattern,surfaceMask:this.surfaceMask}}static parseJSON(t){return[t.radius,t.depth,new P(t.pattern),new b(t.mask)]}}S.set("overlay_brush",V);export{V as OverlayBrush};
