import{Vector as p}from"library/Minecraft.js";var m=(i=>(i[i.Visible=0]="Visible",i[i.NonConvex=1]="NonConvex",i[i.Deleted=2]="Deleted",i))(m||{});class c{constructor(){this.normal=p.ZERO,this.centroid=p.ZERO,this.offset=0,this.outside=null,this.mark=0,this.edge=null,this.nVertices=0}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e-=1;for(;e<0;)t=t.prev,e+=1;return t}computeNormal(){const e=this.edge,t=e.next;let i=t.next,n=t.head().point.sub(e.head().point),o;for(this.nVertices=2,this.normal=p.ZERO;i!==e;)o=n.clone(),n=i.head().point.sub(e.head().point),this.normal=this.normal.add(o.cross(n)),i=i.next,this.nVertices+=1;this.area=this.normal.length,this.normal=this.normal.normalized()}computeNormalMinArea(e){if(this.computeNormal(),this.area<e){let t,i=0,n=this.edge;do{const a=n.lengthSquared();a>i&&(t=n,i=a),n=n.next}while(n!==this.edge);const o=t.tail().point;let s=t.head().point.sub(o);const l=Math.sqrt(i);s=s.mul(1/l);const d=this.normal.dot(s);this.normal=this.normal.add(s.mul(-d)),this.normal=this.normal.normalized()}}computeCentroid(){this.centroid=p.ZERO;let e=this.edge;do this.centroid=this.centroid.add(e.head().point),e=e.next;while(e!==this.edge);this.centroid=this.centroid.mul(1/this.nVertices)}computeNormalAndCentroid(e){typeof e<"u"?this.computeNormalMinArea(e):this.computeNormal(),this.computeCentroid(),this.offset=this.normal.dot(this.centroid)}distanceToPlane(e){return this.normal.dot(e)-this.offset}connectHalfEdges(e,t){let i;if(e.opposite.face===t.opposite.face){const n=t.opposite.face;let o;e===this.edge&&(this.edge=t),n.nVertices===3?(o=t.opposite.prev.opposite,n.mark=2,i=n):(o=t.opposite.next,n.edge===o.prev&&(n.edge=o),o.prev=o.prev.prev,o.prev.next=o),t.prev=e.prev,t.prev.next=t,t.setOpposite(o),n.computeNormalAndCentroid()}else e.next=t,t.prev=e;return i}mergeAdjacentFaces(e,t){const i=e.opposite,n=i.face;t.push(n),n.mark=2;let o=e.prev,r=e.next,s=i.prev,l=i.next;for(;o.opposite.face===n;)o=o.prev,l=l.next;for(;r.opposite.face===n;)r=r.next,s=s.prev;let d;for(d=l;d!==s.next;d=d.next)d.face=this;this.edge=r;let a;return a=this.connectHalfEdges(s,r),a&&t.push(a),a=this.connectHalfEdges(o,l),a&&t.push(a),this.computeNormalAndCentroid(),t}collectIndices(){const e=[];let t=this.edge;do e.push(t.head().index),t=t.next;while(t!==this.edge);return e}static fromVertices(e,t=0){const i=new c,n=new h(e[0],i);let o=n;for(let r=1;r<e.length;r+=1){const s=new h(e[r],i);s.prev=o,o.next=s,o=s}return o.next=n,n.prev=o,i.edge=n,i.computeNormalAndCentroid(t),i}static createTriangle(e,t,i,n=0){const o=new c,r=new h(e,o),s=new h(t,o),l=new h(i,o);return r.next=l.prev=s,s.next=r.prev=l,l.next=s.prev=r,o.edge=r,o.computeNormalAndCentroid(n),o}}class h{constructor(e,t){this.vertex=e,this.face=t,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?this.tail().point.distanceTo(this.head().point):-1}lengthSquared(){return this.tail()?this.tail().point.sub(this.head().point).lengthSqr:-1}setOpposite(e){this.opposite=e,e.opposite=this}}export{c as Face,m as Mark};
