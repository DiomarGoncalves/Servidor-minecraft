import{Vector as h,regionVolume as m,regionSize as d,getCurrentThread as p,regionBounds as g}from"library/Minecraft.js";import{UnloadedChunksError as y}from"./assert.js";import{canPlaceBlock as u}from"../util.js";import b from"config.js";import{Jobs as S}from"./jobs.js";import{RegionBuffer as x}from"./region_buffer.js";let l=0;class P{constructor(c){this.player=c.player,this.changeLimit=c.changeLimit,this.selection=c.selection}assertRecording(){if(!this.isRecording())throw new Error("History was not being recorded!")}assertNotRecording(){if(this.isRecording())throw new Error("History was still being recorded!")}}class H extends P{constructor(){super(...arguments);this.historyPoints=new Map;this.undoStructures=[];this.redoStructures=[];this.selectionHistory=[];this.historyIdx=-1}record(){l++;const o={undo:[],redo:[],blocksChanged:0,thread:p()};return this.historyPoints.set(l,o),l}*commit(o){const t=this.historyPoints.get(o);if(t){for(const e of t.undo){const r=e.location,i=h.add(e.location,e.size).sub(1),s=yield*this.processRegion(o,r,i);t.redo.push({buffer:s,dimension:this.player.dimension,location:h.min(r,i).floor(),size:d(r,i)})}t.selection&&(t.selection=[t.selection,{type:this.selection.mode,points:this.selection.points}])}this.historyPoints.delete(o),this.historyIdx++;for(let e=this.historyIdx;e<this.undoStructures.length;e++)this.deleteHistoryRegions(e);for(this.undoStructures.length=this.redoStructures.length=this.selectionHistory.length=this.historyIdx+1,this.undoStructures[this.historyIdx]=t.undo,this.redoStructures[this.historyIdx]=t.redo,this.selectionHistory[this.historyIdx]=t.selection;this.historyIdx>b.maxHistorySize-1;)this.deleteHistoryRegions(0),this.undoStructures.shift(),this.redoStructures.shift(),this.selectionHistory.shift(),this.historyIdx--}cancel(o){if(!this.historyPoints.has(o))return;const t=this.historyPoints.get(o);this.historyPoints.delete(o);for(const e of t.undo)e.buffer.deref();for(const e of t.redo)e.buffer.deref()}*trackRegion(o,t,e){const r=this.historyPoints.get(o);if(r.blocksChanged+="x"in t?m(t,e):Array.isArray(t)?t.length:t.size,r.blocksChanged>this.changeLimit)throw"commands.generic.wedit:blockLimit";let i;"x"in t?i=t:[i,e]=g(t);const s=yield*this.processRegion(o,i,e);r.undo.push({buffer:s,dimension:this.player.dimension,location:h.min(i,e).floor(),size:d(i,e)})}trackSelection(o){const t=this.historyPoints.get(o);if(!t.selection)t.selection={type:this.selection.mode,points:this.selection.points};else throw new Error('Cannot call "recordSelection" more than once!')}*undo(){if(this.assertNotRecording(),this.historyIdx<=-1)return!0;const t=this.player.dimension;for(const r of this.undoStructures[this.historyIdx])yield*r.buffer.load(r.location,t);let e;if(Array.isArray(this.selectionHistory[this.historyIdx])?e=this.selectionHistory[this.historyIdx][0]:e=this.selectionHistory[this.historyIdx],e){this.selection.mode=e.type;for(let r=0;r<e.points.length;r++)this.selection.set(r==0?0:1,e.points[r])}return this.historyIdx--,!1}*redo(){if(this.assertNotRecording(),this.historyIdx>=this.redoStructures.length-1)return!0;const t=this.player.dimension;this.historyIdx++;for(const r of this.redoStructures[this.historyIdx])yield*r.buffer.load(r.location,t);let e;if(Array.isArray(this.selectionHistory[this.historyIdx])?e=this.selectionHistory[this.historyIdx][1]:e=this.selectionHistory[this.historyIdx],e){this.selection.mode=e.type;for(let r=0;r<e.points.length;r++)this.selection.set(r==0?0:1,e.points[r])}return!1}clear(){this.historyIdx=-1;for(let o=0;o<this.undoStructures.length;o++)this.deleteHistoryRegions(o);this.undoStructures.length=0,this.redoStructures.length=0}isRecording(){return this.historyPoints.size!=0}getActivePointsInThread(o){const t=[];for(const[e,r]of this.historyPoints.entries())r.thread===o&&t.push(e);return t}deleteHistoryRegions(o){try{for(const t of this.undoStructures[o])t.buffer.deref();for(const t of this.redoStructures[o])t.buffer.deref()}catch{}}*processRegion(o,t,e){const i=this.player.dimension;let s;try{if(!S.getContext()&&(!u(t,i)||!u(e,i)))throw new y("worldedit.error.saveHistory");if(s=yield*x.createFromWorld(t,e,i),!s)throw new y("worldedit.error.saveHistory")}catch(a){throw this.cancel(o),a}return s}}let f=H;function F(n){return new f(n)}function J(n){f=n}export{P as History,F as createHistoryBufferForSession,J as setHistoryClass};
