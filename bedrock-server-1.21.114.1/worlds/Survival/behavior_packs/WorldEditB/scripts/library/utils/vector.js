var y,m;import{Direction as a}from"@minecraft/server";const x={[a.Up]:[0,1,0],[a.Down]:[0,-1,0],[a.North]:[0,0,-1],[a.South]:[0,0,1],[a.East]:[1,0,0],[a.West]:[-1,0,0]};class s{constructor(t,n,i){this.vals=[0,0,0];this.vals=[t,n,i]}static get AXES(){return["x","y","z"]}static get ZERO(){return new s(0,0,0)}static get ONE(){return new s(1,1,1)}static get UP(){return new s(0,1,0)}static get DOWN(){return new s(0,-1,0)}static get INF(){return new s(1/0,1/0,1/0)}static get NEG_INF(){return new s(-1/0,-1/0,-1/0)}static from(t){return Array.isArray(t)?new s(...t):typeof t=="string"?new s(...x[t]):new s(t.x,t.y,t.z)}static add(t,n){return s.from(t).add(n)}static sub(t,n){return s.from(t).sub(n)}static mul(t,n){return s.from(t).mul(n)}static div(t,n){return s.from(t).div(n)}static min(t,n){return s.from(t).min(n)}static max(t,n){return s.from(t).max(n)}static equals(t,n){return s.from(t).equals(n)}get x(){return this.vals[0]}set x(t){this.vals[0]=t}get y(){return this.vals[1]}set y(t){this.vals[1]=t}get z(){return this.vals[2]}set z(t){this.vals[2]=t}get lengthSqr(){return this.x*this.x+this.y*this.y+this.z*this.z}get length(){return Math.hypot(...this.vals)}set length(t){const n=this.length;this.x=this.x/n*t,this.y=this.y/n*t,this.z=this.z/n*t}getIdx(t){return this.vals[t]}setIdx(t,n){return this.vals[t]=n}largestAxis(){return this.x>=this.y&&this.x>=this.z?"x":this.y>=this.x&&this.y>=this.z?"y":"z"}clone(){return new s(...this.vals)}equals(t){return t=s.from(t),this.x==t.x&&this.y==t.y&&this.z==t.z}offset(t,n,i){return new s(this.x+t,this.y+n,this.z+i)}distanceTo(t){return this.sub(t).length}add(t){return typeof t=="number"?new s(this.x+t,this.y+t,this.z+t):(t=s.from(t),new s(this.x+t.x,this.y+t.y,this.z+t.z))}sub(t){return typeof t=="number"?new s(this.x-t,this.y-t,this.z-t):(t=s.from(t),new s(this.x-t.x,this.y-t.y,this.z-t.z))}mul(t){return typeof t=="number"?new s(this.x*t,this.y*t,this.z*t):(t=s.from(t),new s(this.x*t.x,this.y*t.y,this.z*t.z))}div(t){return typeof t=="number"?new s(this.x/t,this.y/t,this.z/t):(t=s.from(t),new s(this.x/t.x,this.y/t.y,this.z/t.z))}rotate(t,n){if(!t)return this.clone();const i=(t%360+360)%360,h=(i>180?i-360:i)*(Math.PI/180),e=Math.cos(h),r=Math.sin(h);return n==="x"?new s(this.x,Math.round(1e4*(this.y*e-this.z*r))/1e4,Math.round(1e4*(this.y*r+this.z*e))/1e4):n==="y"?new s(Math.round(1e4*(this.x*e-this.z*r))/1e4,this.y,Math.round(1e4*(this.x*r+this.z*e))/1e4):new s(Math.round(1e4*(this.x*e-this.y*r))/1e4,Math.round(1e4*(this.x*r+this.y*e))/1e4,this.z)}min(t){return t=s.from(t),new s(Math.min(this.x,t.x),Math.min(this.y,t.y),Math.min(this.z,t.z))}max(t){return t=s.from(t),new s(Math.max(this.x,t.x),Math.max(this.y,t.y),Math.max(this.z,t.z))}floor(){return new s(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z))}ceil(){return new s(Math.ceil(this.x),Math.ceil(this.y),Math.ceil(this.z))}round(){return new s(Math.round(this.x),Math.round(this.y),Math.round(this.z))}lerp(t,n){return t=s.from(t),new s((1-n)*this.x+n*t.x,(1-n)*this.y+n*t.y,(1-n)*this.z+n*t.z)}abs(){return new s(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}map(t){return new s(...this.vals.map(t))}normalized(){const t=new s(...this.vals);return t.length=1,t}dot(t){return t=s.from(t),this.x*t.x+this.y*t.y+this.z*t.z}cross(t){return t=s.from(t),new s(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}transform(t){const[n,i,h]=this.vals,e=t.vals,r=1/(e[3]*n+e[7]*i+e[11]*h+e[15]),u=new s(0,0,0);return u.x=(e[0]*n+e[4]*i+e[8]*h+e[12])*r,u.y=(e[1]*n+e[5]*i+e[9]*h+e[13])*r,u.z=(e[2]*n+e[6]*i+e[10]*h+e[14])*r,u}transformDirection(t){const[n,i,h]=this.vals,e=t.vals,r=new s(0,0,0);return r.x=e[0]*n+e[4]*i+e[8]*h,r.y=e[1]*n+e[5]*i+e[9]*h,r.z=e[2]*n+e[6]*i+e[10]*h,r.length=this.length,r}print(){return`${this.x} ${this.y} ${this.z}`}toAngles(){return{x:Math.asin(-this.y),y:Math.atan2(-this.x,this.z)}}toArray(){return[this.x,this.y,this.z]}toString(){return`(${this.vals[0]}, ${this.vals[1]}, ${this.vals[2]})`}*[Symbol.iterator](){yield this.vals[0],yield this.vals[1],yield this.vals[2]}}m=Symbol.iterator,y=Symbol.toStringTag;class d{constructor(){this.map=new Map;this.keys=this.values;this[m]=this.values;this[y]="vectorSet"}get size(){return this.map.size}add(t){return this.map.set(`${t.x} ${t.y} ${t.z}`,t),this}clear(){this.map.clear()}delete(t){return this.map.delete(`${t.x} ${t.y} ${t.z}`)}*values(){for(const t of this.map.values())yield t}*entries(){for(const t of this.map.values())yield[t,t]}forEach(t,n){for(const i of this.entries())t.apply(n,[i[0],i[1],this])}has(t){return this.map.has(`${t.x} ${t.y} ${t.z}`)}}export{s as Vector,d as VectorSet};
