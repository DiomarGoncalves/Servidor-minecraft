import{Server as k,Vector as m,iterateChunk as g,regionIterateBlocks as S,whenReady as I}from"library/Minecraft.js";import{brushTypes as w,Brush as P}from"./base_brush.js";import{BlockPermutation as y}from"@minecraft/server";import{directionVectors as B}from"server/modules/directions.js";import{getWorldHeightLimits as F}from"server/util.js";import{recordBlockChanges as O}from"server/modules/block_changes.js";import{SphereShape as v}from"server/shapes/sphere.js";class f{constructor(b,r,i,o){this.erodeThreshold=b,this.erodeIterations=r,this.fillThreshold=i,this.fillIterations=o}}var L=(e=>(e[e.DEFAULT=0]="DEFAULT",e[e.LIFT=1]="LIFT",e[e.FILL=2]="FILL",e[e.MELT=3]="MELT",e[e.SMOOTH=4]="SMOOTH",e))(L||{});let T;I(()=>T={"minecraft:air":y.resolve("air"),"minecraft:water":y.resolve("water"),"minecraft:lava":y.resolve("lava")});class x extends P{constructor(r,i){super();this.id="erosion_brush";this.assertSizeInRange(r),this.radius=r,this.preset=E.get(i),this.type=i}resize(r){this.assertSizeInRange(r),this.radius=r}getSize(){return this.radius}getType(){return this.type}paintWith(){throw"commands.generic.wedit:noMaterial"}*apply(r,i,o){const e=[r.sub(this.radius),r.add(this.radius)],[h,c]=F(i.player.dimension),d=(o?i.globalMask?o.intersect(i.globalMask):o:i.globalMask)?.withContext(i);e[0].y=Math.max(h,e[0].y),e[1].y=Math.min(c,e[1].y);const s=i.history,a=s.record(),n=O(i,a);try{const t=[],l=m.add(...e).mul(.5),u=(this.radius+.5)*(this.radius+.5);for(const p of S(...e))l.sub(p).lengthSqr<=u&&t.push(p);for(let p=0;p<this.preset.erodeIterations;p++)yield*this.processErosion(t,this.preset.erodeThreshold,n,d);for(let p=0;p<this.preset.fillIterations;p++)yield*this.processFill(t,this.preset.fillThreshold,n,d);yield*n.flush(),yield*s.commit(a)}catch(t){throw s.cancel(a),t}}getOutline(){return[new v(this.radius),m.ZERO]}*processErosion(r,i,o,e){const h=k.block.isAirOrFluid;for(const c of r){if(h(o.getBlockPerm(c))||e&&!e.matchesBlock(o.dimension.getBlock(c)))continue;let d=0;const s=[];for(const[a,n]of B){const t=o.getBlockPerm(m.add(c,n));if(h(t)){d++;let l=!1;for(let u=0;u<s.length;u++)if(s[u][0]==t.type.id){s[u][1]++,l=!0;break}l||s.push([t.type.id,1])}}if(d>=i){let a=0,n;for(const[t,l]of s)l>a&&(a=l,n=t);o.setBlock(c,T[n])}g()&&(yield 0)}o.applyIteration()}*processFill(r,i,o,e){const h=k.block.isAirOrFluid;for(const c of r){if(!h(o.getBlockPerm(c)))continue;let d=0;const s=[];for(const[a,n]of B){const t=o.getBlockPerm(m.add(c,n));if(!h(t)&&(!e||e.matchesBlock(o.dimension.getBlock(m.add(c,n))))){d++;let l=!1;for(let u=0;u<s.length;u++)if(s[u][0].matches(t.type.id,t.getAllStates())){s[u][1]++,l=!0;break}l||s.push([t,1])}}if(d>=i){let a=0,n;for(const[t,l]of s)l>a&&(a=l,n=t);o.setBlock(c,n)}g()&&(yield 0)}o.applyIteration()}toJSON(){return{id:this.id,radius:this.radius,type:this.type}}static parseJSON(r){return[r.radius,r.type]}}w.set("erosion_brush",x);const E=new Map([[0,new f(1,1,6,0)],[1,new f(6,0,1,1)],[2,new f(5,1,2,1)],[3,new f(2,1,5,1)],[4,new f(3,1,3,1)]]);export{x as ErosionBrush,L as ErosionType};
