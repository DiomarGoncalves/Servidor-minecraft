import{Shape as u}from"./base_shape.js";import{Vector as s}from"library/Minecraft.js";class y extends u{constructor(e,t){super();this.customHollow=!1;this.size=e,this.expr=t}getRegion(e){return[e,e.offset(this.size.x-1,this.size.y-1,this.size.z-1)]}getYRange(){throw Error("YRange not implemented")}getOutline(){const e=s.ZERO,t=s.from(this.size),r=[new s(e.x,e.y,e.z),new s(t.x,e.y,e.z),new s(e.x,t.y,e.z),new s(t.x,t.y,e.z),new s(e.x,e.y,t.z),new s(t.x,e.y,t.z),new s(e.x,t.y,t.z),new s(t.x,t.y,t.z)],o=[[0,1],[2,3],[4,5],[6,7],[0,2],[1,3],[4,6],[5,7],[0,4],[1,5],[2,6],[3,7]];return this.drawShape(r,o)}prepGeneration(e,t){e.hollow=t.hollow,e.neighbourOffsets=[[0,1,0],[0,-1,0],[1,0,0],[-1,0,0],[0,0,1],[0,0,-1]],e.func=this.expr.compile()}inShape(e,t){const r=(n,i,h)=>{const p=[(e.x+n)/Math.max(this.size.x-1,1)*2-1,(e.y+i)/Math.max(this.size.y-1,1)*2-1,(e.z+h)/Math.max(this.size.z-1,1)*2-1],c=t.func(p[0],p[1],p[2]);return c==!0||c>0},o=r(0,0,0);if(t.hollow&&o){let n=0;for(const i of t.neighbourOffsets)n+=r(...i)?1:0;return n==6?!1:o}else return o}}export{y as ExpressionShape};
