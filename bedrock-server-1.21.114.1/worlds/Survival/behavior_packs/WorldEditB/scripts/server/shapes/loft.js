import{BlockVolume as A}from"@minecraft/server";import{Shape as L}from"./base_shape";import{Vector as l,VectorSet as R}from"library/Minecraft.js";import{plotCurve as x,plotTriangle as M,Spline as k,TensionVector as V}from"server/commands/region/paths_func";import{Jobs as C}from"server/modules/jobs";class I extends L{constructor(e=[]){super();this.customHollow=!1;this.curves=[];this.start=l.ZERO;this.end=l.ZERO;this.curves=e.map(i=>i.map(o=>V.from(o))),this.updateParticles()}newCurve(e){this.curves.push([V.from(e)]),this.updateParticles()}addPoint(e){this.curves.length||this.curves.push([]),this.curves[this.curves.length-1].push(V.from(e)),this.updateParticles()}removeLastPoint(){return this.curves.length?(this.curves[this.curves.length-1].pop(),this.curves[this.curves.length-1].length||this.curves.pop(),this.updateParticles(),this.curves.length>0):!1}getRegion(e){return[this.start.add(e),this.end.add(e)]}getYRange(){throw new Error("Method not implemented.")}prepGeneration(){}*calculateShape(e,i,o,t){const r=new R,m=new A(o,t);function*h(s){m.isInside(s)&&r.add(e.getBlock(s)??(yield*C.loadBlock(s)))}const y=this.curves.map(s=>new k(s)),S=y.reduce((s,n)=>Math.max(s,n.length),0),w=Math.floor(S/4)+1;let f=0;const c=[];for(let s=0;s<=w;s++){const n=new k(y.map(u=>u.sample(s/w)));f=Math.max(f,n.length),c.push(n)}const p=Math.floor(f/4)+1;for(let s=1;s<c.length;s++){const n=c[s-1],u=c[s];let b=n.sample(0).add(.5),v=u.sample(0).add(.5);for(let d=1;d<=p;d++){const B=d/p,g=n.sample(B).add(.5),P=u.sample(B).add(.5);for(const a of M(b,g,v))r.has(a)?yield:yield*h(a);for(const a of M(g,v,P))r.has(a)?yield:yield*h(a);yield C.setProgress((d+s*p)/(p*c.length)),b=g,v=P}}return[r,r.size]}getOutline(){this.start=new l(1/0,1/0,1/0),this.end=new l(-1/0,-1/0,-1/0);const e=[],i=this.curves.reduce((t,r)=>Math.max(t,r.length),0),o=this.curves.map(t=>Array.from(x(t,{precision:2,plotLines:!1})));for(const t of o)e.push(...this.drawLine(t.map(r=>r.add(.5)),!1,!0));if(o.length>1)for(let t=0;t<i;t++)e.push(...this.drawLine(Array.from(x(o.map(r=>I.sampleCurve(r,t/Math.max(i-1,1))),{precision:2,plotLines:!1})).map(r=>r.add(.5)),!1,!0));for(const[,t]of e)this.start=this.start.min(t),this.end=this.end.max(t);return e}updateParticles(){this.outlineCache=this.getOutline()}static sampleCurve(e,i){const o=e.length-1,t=Math.floor(i*o),r=i*o-t;if(t>=o)return e[o];const m=e[t],h=e[t+1];return l.from(m).lerp(h,r)}}export{I as LoftShape};
