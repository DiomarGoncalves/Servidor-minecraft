import{Jobs as M}from"../../modules/jobs.js";import{Mask as X}from"../../modules/mask.js";import{RegionBuffer as Y}from"../../modules/region_buffer.js";import{Vector as R}from"library/Minecraft.js";const b={createMap:function(t,y){const m=[];for(let f=0;f<t;f++){const s=[];for(let o=0;o<y;o++)s.push(void 0);m.push(s)}return m},modifyMap:function*(t,y,m){let f=0;const s=t.length*t[0].length;yield M.nextStep(m);for(let o=0;o<t.length;o++)for(let e=0;e<t[o].length;e++){const a=y(o,e);t[o][e]=a&&typeof a=="object"?yield*a:a,yield M.setProgress(++f/s)}},getMap:function(t,y,m){return t[y]?.[m]??void 0}};function*O(t,y,m,f,s,o){return yield*j(t,function*({x:e,z:a},k,r){const h=r.createMap(e,a);for(let x=0;x<y;x++)yield*r.modifyMap(h,(l,u)=>{const d=r.getMap(k,l,u);if(d==null)return;let p=d*.6;return p+=(r.getMap(k,l,u-1)??d)*.2,p+=(r.getMap(k,l,u+1)??d)*.2,p},"worldbuilder.oreville_wb:job.height.smooth"),yield*r.modifyMap(k,(l,u)=>{const d=r.getMap(h,l,u);if(d==null)return;let p=d*.6;return p+=(r.getMap(h,l-1,u)??d)*.2,p+=(r.getMap(h,l+1,u)??d)*.2,p},"worldbuilder.oreville_wb:job.height.smooth")},m,f,s,o)}function*j(t,y,m,f,s,o){const[e,a]=m.getRegion(f),r=t.player.dimension,{min:h,max:x}=r.heightRange;e.y=Math.max(h,e.y),a.y=Math.min(x-1,a.y),o=(o?o.intersect(t.globalMask):t.globalMask)?.clone()??new X,s=s.clone();const[l,u]=[a.x-e.x+1,a.z-e.z+1],d=b.createMap(l,u),p=b.createMap(l,u),J=b.createMap(l,u),z=b.createMap(l,u);yield*b.modifyMap(d,function*(c,g){const i=m.getYRange(c,g);if(!i)return;i[0]=Math.max(i[0]+f.y,h),i[1]=Math.min(i[1]+f.y,x);let n;for(n=new R(c+e.x,i[1],g+e.z);n.y>=i[0];n.y--){const B=r.getBlock(n)??(yield*M.loadBlock(n));if(!B.isAir&&s.matchesBlock(B))break}if(n.y!=i[0]-1)return z[c][g]=n.y,p[c][g]=i[0],J[c][g]=i[1],n.y},"Getting heightmap..."),yield*y({x:l,z:u},d,b);let G=0;const S=t.history,V=S.record(),F=a.y-e.y;let w;try{yield*S.trackRegion(V,e,a),yield M.nextStep("Calculating blocks..."),w=yield*Y.create(e,a,function*(c){function*g(i){const n=R.add(i,e),B=r.getBlock(n)??(yield*M.loadBlock(n));return B.isAir||o.matchesBlock(B)}if(yield*g(c)){const i=b.getMap(d,c.x,c.z)-b.getMap(z,c.x,c.z),n=R.add(c,[0,-i,0]).round();if(n.y=Math.min(Math.max(n.y,0),F),!isNaN(i)&&(yield*g(n)))return r.getBlock(n.add(e))}}),yield M.nextStep("Placing blocks"),w&&(yield*w.load(e,r),G=w.getVolume()),yield*S.commit(V)}catch(c){throw S.cancel(V),c}finally{w?.deref()}return G}export{j as modifyHeight,O as smooth};
