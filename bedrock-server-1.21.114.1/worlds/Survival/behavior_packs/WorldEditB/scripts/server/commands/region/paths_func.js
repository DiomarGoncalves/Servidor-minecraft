import{regionBounds as A,regionIterateBlocks as w,Vector as l,VectorSet as v}from"library/Minecraft.js";function*O(f,t,n){const e=l.from(f),s=l.from(t),i=l.from(n),o=s.sub(e),r=i.sub(s),c=e.sub(i),a=[o.cross(r),new l(1,0,0),new l(0,1,0),new l(0,0,1),o.cross([1,0,0]),o.cross([0,1,0]),o.cross([0,0,1]),r.cross([1,0,0]),r.cross([0,1,0]),r.cross([0,0,1]),c.cross([1,0,0]),c.cross([0,1,0]),c.cross([0,0,1])],u=new l(.5,.5,.5);function h(p){const b=l.add(p,.5),[x,V,k]=[e,s,i].map(g=>g.sub(b));for(const g of a)if(!d(g,x,V,k,u))return!1;return!0}function d(p,b,x,V,k){const g=b.dot(p),K=x.dot(p),P=V.dot(p),S=Math.min(g,K,P),M=Math.max(g,K,P),I=k.x*Math.abs(p.x)+k.y*Math.abs(p.y)+k.z*Math.abs(p.z);return!(S>I||M<-I)}const m=new v;for(const p of w(...A([e,s,i].map(b=>b.floor()))))h(p)&&(yield p);return m}function*T(f,t){const n=l.sub(t,f),e=n.map(Math.sign),s=n.abs(),i=s.mul(2),o=s.largestAxis(),r=i.sub(s[o]),c=l.from(f),a=new v;for(let u=0;u<s[o];u++){a.add(c),yield c.clone();for(const h of l.AXES)r[h]>0&&(c[h]+=e[h],r[h]-=i[o]),r[h]+=i[h]}return a.add(c),yield c.clone(),a}function*z(f,t){return yield*new j(f.map(n=>y.from(n))).plotCurve(t?.plotLines??!0,t?.precision??4)}function*D(f,t){const n=new v;for(const e of f){const s=l.from(e);for(const i of w(l.sub(e,t),l.add(e,t))){if(s.distanceTo(i)>=t+.5||n.has(i))continue;const o=l.from(i);n.add(o),yield o}}return n}class y extends l{static from(t,n=0,e=0,s=0){return new y(t.x,t.y,t.z,n,e,s)}constructor(t,n,e,s,i,o){super(t,n,e),this.t=s,this.c=i,this.b=o}get t(){return this.tParam}set t(t){this.tParam=t<0?0:t>1?1:t}get c(){return this.cParam}set c(t){this.cParam=t<0?0:t>1?1:t}get b(){return this.bParam}set b(t){this.bParam=t<0?0:t>1?1:t}}class j{constructor(t){this.knots=[];this.internalKnots=[];this.hypotenuseSum=0;this.knots=[...t],this.update()}sample(t){if(t<=0)return this.knots[0];if(t>=1)return this.knots[this.knots.length-1];const n=t*this.hypotenuseSum,e=this.arbitraryInterval(n);return typeof e!="object"||isNaN(e.t)?this.knots[0]:this.calcPosition(e.t,e.k)}update(){this.internalKnots=[this.knots[0],...this.knots,this.knots[this.knots.length-1],this.knots[this.knots.length-1]],this.hypotenuseSum=0;for(let t=1;t<this.internalKnots.length-1;t++)this.hypotenuseSum+=this.hypotenuseAtKnot(t)}get length(){return this.hypotenuseSum}prependKnot(t){this.knots.unshift(t),this.update()}appendKnot(t){this.knots.push(t),this.update()}firstKnot(){return this.knots[0]}lastKnot(){return this.knots[this.knots.length-1]}nthKnot(t){return this.knots[t]}seriesOfKnots(t,n){if(!(Math.sign(t)===-1||Math.sign(n)===-1))return this.knots.slice(t,n+1)}h0(t){return(1+2*t)*((1-t)*(1-t))}h1(t){return t*((1-t)*(1-t))}h2(t){return t*t*(3-2*t)}h3(t){return t*t*(t-1)}hypotenuseAtKnot(t){const n=this.internalKnots[t],e=this.internalKnots[t+1];return l.sub(n,e).length}arbitraryInterval(t){const n=[],e=this.hypotenuseSum;for(let o=1;o<this.internalKnots.length-1;o++){const r={x:0,l:this.hypotenuseAtKnot(o)};n.length>0&&(r.x=n[n.length-1].x+n[n.length-1].l),n.push(r)}let s=0;if(t<0)return 0;if(t>e)return 1;let i=0;for(let o=0;o<n.length;o++)if(t>=n[o].x&&t<=n[o].x+n[o].l){i=(t-n[o].x)/n[o].l,s=o+1;break}return{t:i,k:s}}d(t){const n=[],e=this.internalKnots[t-1],s=this.internalKnots[t],i=this.internalKnots[t+1],o=this.internalKnots[t+2];for(let r=0;r<2;r++){const c=new y(0,0,0,0,0,0);let a=0,u=0,h,d;r===0?(a=(1-s.t)*(1+s.b)*(1+s.c)*.5,u=(1-s.t)*(1-s.b)*(1-s.c)*.5,h={p0:s,p1:e},d={p0:i,p1:s}):(a=(1-i.t)*(1+i.b)*(1-i.c)*.5,u=(1-i.t)*(1-i.b)*(1+i.c)*.5,h={p0:i,p1:s},d={p0:o,p1:i});for(let m=0;m<3;m++){const p=a*(h.p0.getIdx(m)-h.p1.getIdx(m)),b=u*(d.p0.getIdx(m)-d.p1.getIdx(m));c.setIdx(m,p+b)}n.push(c)}return n}calcPosition(t,n){const e=new y(0,0,0,0,0,0),s=this.internalKnots[n],i=this.internalKnots[n+1],o=this.d(n);for(let r=0;r<3;r++){const c=this.h0(t)*s.getIdx(r),a=this.h1(t)*o[0].getIdx(r),u=this.h2(t)*i.getIdx(r),h=this.h3(t)*o[1].getIdx(r);e.setIdx(r,c+a+u+h)}return e}*plotCurve(t=!0,n=4){const e=new v;if(this.knots.length<1)return e;if(this.knots.length<2){const r=l.from(this.knots[0]);return yield r,e.add(r)}let s=new l(0,0,0);const i=this.hypotenuseSum;for(let r=0;r<i;r+=n){const c=this.arbitraryInterval(r);if(typeof c=="object"&&!isNaN(c.t)){const a=this.calcPosition(c.t,c.k),u=a.add(.5).floor();if(!t)e.has(a)||(e.add(a),yield a);else if(c.t!==0)for(const h of T(s,u))e.has(h)||(e.add(h),yield h);s=u}}const o=this.arbitraryInterval(i);if(typeof o=="object"&&!isNaN(o.t)){const r=this.calcPosition(o.t,o.k),c=r.add(.5).floor();if(!t)e.has(r)||(e.add(r),yield r);else if(!s.floor().equals(c.floor()))for(const a of T(s,c))e.has(a)||(e.add(a),yield a)}return e}}export{j as Spline,y as TensionVector,D as balloonPath,z as plotCurve,T as plotLine,O as plotTriangle};
