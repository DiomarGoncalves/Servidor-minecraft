const p=(_,t)=>{const e=_.length;let i=t-20;i<0&&(i=0);let n=t+20;n>e&&(n=e);const s=h=>h.charCodeAt(0).toString(16).toUpperCase(),r=(h,l,a)=>h.substr(l,a).replace(/\\/g,"\\\\").replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g,o=>"\\x0"+s(o)).replace(/[\x10-\x1F\x80-\xFF]/g,o=>"\\x"+s(o)).replace(/[\u0100-\u0FFF]/g,o=>"\\u0"+s(o)).replace(/[\u1000-\uFFFF]/g,o=>"\\u"+s(o));return{prologTrunc:i>0,prologText:r(_,i,t-i),tokenText:r(_,t,1),epilogText:r(_,t+1,n-(t+1)),epilogTrunc:n<e}};class u{constructor(t,e,i,n=0,s=0,r=0){this.type=t,this.value=e,this.text=i,this.pos=n,this.line=s,this.column=r}toString(t=(e,i)=>i){return`${t("type",this.type)} (value: ${t("value",JSON.stringify(this.value))}, text: ${t("text",JSON.stringify(this.text))}, pos: ${t("pos",this.pos)}, line: ${t("line",this.line)}, column: ${t("column",this.column)})`}isA(t,e){return!(t!==this.type||arguments.length===2&&e!==this.value)}}class g extends Error{constructor(t,e,i,n,s){super(t),this.name="ParsingError",this.message=t,this.pos=e,this.line=i,this.column=n,this.input=s}toString(){const t=p(this.input,this.pos),e=`line ${this.line} (column ${this.column}): `;let i="   ";for(let s=0;s<e.length+t.prologText.length;s++)i+=" ";return"Parsing Error: "+this.message+`
`+e+t.prologText+t.tokenText+t.epilogText+`
`+i+"^"}}class f{constructor(t){this._tokenizr=t,this._data={},this._repeat=!1,this._reject=!1,this._ignore=!1,this._match=null}data(t,e){const i=this._data[t];return arguments.length===2&&(this._data[t]=e),i}info(){return{line:this._tokenizr._line,column:this._tokenizr._column,pos:this._tokenizr._pos,len:this._match[0].length}}push(...t){return this._tokenizr.push(...t),this}pop(...t){return this._tokenizr.pop(...t)}state(...t){return t.length>0?(this._tokenizr.state(...t),this):this._tokenizr.state(...t)}tag(...t){return this._tokenizr.tag(...t),this}tagged(...t){return this._tokenizr.tagged(...t)}untag(...t){return this._tokenizr.untag(...t),this}repeat(){return this._tokenizr._log("    REPEAT"),this._repeat=!0,this}reject(){return this._tokenizr._log("    REJECT"),this._reject=!0,this}ignore(){return this._tokenizr._log("    IGNORE"),this._ignore=!0,this}accept(t,e){return arguments.length<2&&(e=this._match[0]),this._tokenizr._log(`    ACCEPT: type: ${t}, value: ${JSON.stringify(e)} (${typeof e}), text: "${this._match[0]}"`),this._tokenizr._pending.push(new u(t,e,this._match[0],this._tokenizr._pos,this._tokenizr._line,this._tokenizr._column)),this}stop(){return this._tokenizr._stopped=!0,this}}class c{constructor(){this._before=null,this._after=null,this._finish=null,this._rules=[],this._debug=!1,this.reset()}reset(){return this._input="",this._len=0,this._eof=!1,this._pos=0,this._line=1,this._column=1,this._state=["default"],this._tag={},this._transaction=[],this._pending=[],this._stopped=!1,this._ctx=new f(this),this}error(t){return new g(t,this._pos,this._line,this._column,this._input)}debug(t){return this._debug=t,this}_log(t){this._debug&&console.log(`tokenizr: ${t}`)}input(t){if(typeof t!="string")throw new Error('parameter "input" not a String');return this.reset(),this._input=t,this._len=t.length,this}push(t){if(arguments.length!==1)throw new Error("invalid number of arguments");if(typeof t!="string")throw new Error('parameter "state" not a String');return this._log(`    STATE (PUSH): old: <${this._state[this._state.length-1]}>, new: <${t}>`),this._state.push(t),this}pop(){if(arguments.length!==0)throw new Error("invalid number of arguments");if(this._state.length<2)throw new Error("no more custom states to pop");return this._log(`    STATE (POP): old: <${this._state[this._state.length-1]}>, new: <${this._state[this._state.length-2]}>`),this._state.pop()}state(t){if(arguments.length===1){if(typeof t!="string")throw new Error('parameter "state" not a String');return this._log(`    STATE (SET): old: <${this._state[this._state.length-1]}>, new: <${t}>`),this._state[this._state.length-1]=t,this}else{if(arguments.length===0)return this._state[this._state.length-1];throw new Error("invalid number of arguments")}}tag(t){if(arguments.length!==1)throw new Error("invalid number of arguments");if(typeof t!="string")throw new Error('parameter "tag" not a String');return this._log(`    TAG (ADD): ${t}`),this._tag[t]=!0,this}tagged(t){if(arguments.length!==1)throw new Error("invalid number of arguments");if(typeof t!="string")throw new Error('parameter "tag" not a String');return this._tag[t]===!0}untag(t){if(arguments.length!==1)throw new Error("invalid number of arguments");if(typeof t!="string")throw new Error('parameter "tag" not a String');return this._log(`    TAG (DEL): ${t}`),delete this._tag[t],this}before(t){return this._before=t,this}after(t){return this._after=t,this}finish(t){return this._finish=t,this}rule(t,e,i,n="unknown"){if(arguments.length===2&&typeof e=="function"?([e,i]=[t,e],t="*"):arguments.length===3&&typeof e=="function"&&([e,i,n]=[t,e,i],t="*"),typeof t!="string")throw new Error('parameter "state" not a String');if(!(typeof e=="object"&&e instanceof RegExp))throw new Error('parameter "pattern" not a RegExp');if(typeof i!="function")throw new Error('parameter "action" not a Function');if(typeof n!="string")throw new Error('parameter "name" not a String');t=t.split(/\s*,\s*/g).map(r=>{const h=r.split(/\s+/g),l=h.filter(o=>o.match(/^#/)===null),a=h.filter(o=>o.match(/^#/)!==null).map(o=>o.replace(/^#/,""));if(l.length!==1)throw new Error("exactly one state required");return{state:l[0],tags:a}});let s="g";try{typeof new RegExp("","y").sticky=="boolean"&&(s="y")}catch{}return typeof e.multiline=="boolean"&&e.multiline&&(s+="m"),typeof e.dotAll=="boolean"&&e.dotAll&&(s+="s"),typeof e.ignoreCase=="boolean"&&e.ignoreCase&&(s+="i"),typeof e.unicode=="boolean"&&e.unicode&&(s+="u"),e=new RegExp(e.source,s),this._log(`rule: configure rule (state: ${t}, pattern: ${e.source})`),this._rules.push({state:t,pattern:e,action:i,name:n}),this}_progress(t,e){const i=this._line,n=this._column,s=this._input;for(let r=t;r<e;r++){const h=s.charAt(r);h==="\r"?this._column=1:h===`
`?(this._line++,this._column=1):h==="	"?this._column+=8-this._column%8:this._column++}this._log(`    PROGRESS: characters: ${e-t}, from: <line ${i}, column ${n}>, to: <line ${this._line}, column ${this._column}>`)}_tokenize(){const t=()=>{this._eof||(this._finish!==null&&this._finish.call(this._ctx,this._ctx),this._eof=!0,this._pending.push(new u("EOF","","",this._pos,this._line,this._column)))};if(this._stopped||this._pos>=this._len){t();return}let e=!0;for(;e;){if(e=!1,this._debug){const i=p(this._input,this._pos),n=Object.keys(this._tag).map(s=>`#${s}`).join(" ");this._log(`INPUT: state: <${this._state[this._state.length-1]}>, tags: <${n}>, text: `+(i.prologTrunc?"...":'"')+`${i.prologText}<${i.tokenText}>${i.epilogText}`+(i.epilogTrunc?"...":'"')+`, at: <line ${this._line}, column ${this._column}>`)}for(let i=0;i<this._rules.length;i++){if(this._debug){const l=this._rules[i].state.map(a=>{let o=a.state;return a.tags.length>0&&(o+=" "+a.tags.map(m=>`#${m}`).join(" ")),o}).join(", ");this._log(`  RULE: state(s): <${l}>, pattern: ${this._rules[i].pattern.source}`)}let n=!1;const s=this._rules[i].state.map(l=>l.state);let r=s.indexOf("*");if(r<0&&(r=s.indexOf(this._state[this._state.length-1])),r>=0){n=!0;let l=this._rules[i].state[r].tags;l=l.filter(a=>!this._tag[a]),l.length>0&&(n=!1)}if(!n)continue;this._rules[i].pattern.lastIndex=this._pos;let h=this._rules[i].pattern.exec(this._input);if(this._rules[i].pattern.lastIndex=this._pos,(h=this._rules[i].pattern.exec(this._input))!==null&&h.index===this._pos){if(this._debug&&this._log("    MATCHED: "+JSON.stringify(h)),this._ctx._match=h,this._ctx._repeat=!1,this._ctx._reject=!1,this._ctx._ignore=!1,this._before!==null&&this._before.call(this._ctx,this._ctx,h,this._rules[i]),this._rules[i].action.call(this._ctx,this._ctx,h),this._after!==null&&this._after.call(this._ctx,this._ctx,h,this._rules[i]),this._ctx._reject)continue;if(this._ctx._repeat){e=!0;break}else if(this._ctx._ignore){if(this._progress(this._pos,this._rules[i].pattern.lastIndex),this._pos=this._rules[i].pattern.lastIndex,this._pos>=this._len){t();return}e=!0;break}else if(this._pending.length>0){this._progress(this._pos,this._rules[i].pattern.lastIndex),this._pos=this._rules[i].pattern.lastIndex,this._pos>=this._len&&t();return}else throw new Error('action of pattern "'+this._rules[i].pattern.source+'" neither rejected nor accepted any token(s)')}}}throw this.error("token not recognized")}token(){if(this._pending.length===0&&this._tokenize(),this._pending.length>0){const t=this._pending.shift();return this._transaction.length>0&&this._transaction[0].push(t),this._log(`TOKEN: ${t.toString()}`),t}return null}tokens(){const t=[];let e;for(;(e=this.token())!==null;)t.push(e);return t}peek(t){typeof t>"u"&&(t=0);for(let e=0;e<this._pending.length+t;e++)this._tokenize();if(t>=this._pending.length)throw new Error("not enough tokens available for peek operation");return this._log(`PEEK: ${this._pending[t].toString()}`),this._pending[t]}skip(t){typeof t>"u"&&(t=1);for(let e=0;e<this._pending.length+t;e++)this._tokenize();if(t>this._pending.length)throw new Error("not enough tokens available for skip operation");for(;t-- >0;)this.token();return this}consume(t,e){for(let s=0;s<this._pending.length+1;s++)this._tokenize();if(this._pending.length===0)throw new Error("not enough tokens available for consume operation");const i=this.token();this._log(`CONSUME: ${i.toString()}`);const n=()=>{throw new g(`expected: <type: ${t}, value: ${JSON.stringify(e)} (${typeof e})>, found: <type: ${i.type}, value: ${JSON.stringify(i.value)} (${typeof i.value})>`,i.pos,i.line,i.column,this._input)};return arguments.length===2&&!i.isA(t,e)?n(JSON.stringify(e),typeof e):i.isA(t)||n("*","any"),i}begin(){return this._log(`BEGIN: level ${this._transaction.length}`),this._transaction.unshift([]),this}depth(){if(this._transaction.length===0)throw new Error("cannot determine depth -- no active transaction");return this._transaction[0].length}commit(){if(this._transaction.length===0)throw new Error("cannot commit transaction -- no active transaction");const t=this._transaction.shift();return this._transaction.length>0&&(this._transaction[0]=this._transaction[0].concat(t)),this._log(`COMMIT: level ${this._transaction.length}`),this}rollback(){if(this._transaction.length===0)throw new Error("cannot rollback transaction -- no active transaction");const t=this._transaction.shift();return this._pending=t.concat(this._pending),this._log(`ROLLBACK: level ${this._transaction.length}`),this}alternatives(...t){let e=null,i=[];for(let n=0;n<t.length;n++)try{this.begin(),e=t[n].call(this),this.commit();break}catch(s){this._log(`EXCEPTION: ${s.toString()}`),i.push({ex:s,depth:this.depth()}),this.rollback();continue}if(e===null&&i.length>0)throw i=i.sort((n,s)=>n.depth-s.depth),i[0].ex;return e}}c.Token=u,c.ParsingError=g,c.ActionContext=f;export{g as ParsingError,u as Token,c as Tokenizr};
