import{contentLog as O,generateId as U,iterateChunk as V,Matrix as P,regionIterateBlocks as E,regionSize as D,regionTransformedBounds as L,regionVolume as I,Thread as K,Vector as t}from"library/Minecraft.js";import{Block as Y,BlockPermutation as Q,StructureMirrorAxis as A,StructureRotation as T,StructureSaveMode as J,system as tt,world as p}from"@minecraft/server";import{blockHasNBTData as et,locToString as x,stringToLoc as G,wrap as rt}from"../util.js";import{Jobs as S}from"./jobs.js";const w=class w{constructor(e,r){this.structures={};this.extraBlockData={};this.size=t.ZERO;this.volume=0;this.refCount=1;O.debug("creating structure",this.id),this.id=e??"wedit:buffer_"+U(),this.savedToWorld=e!==void 0,r?this.getBlock=this.getBlockMulti:this.getBlock=this.getBlockSingle}static*create(e,r,i){const s=t.min(e,r),u=t.from(D(e,r)),a=yield*this.saveStructs(void 0,e,r,(d,l,n)=>p.structureManager.createEmpty(d,D(l,n)));if(!a)return;const o=I(e,r);a.volume=o,a.size=u;let f=0;for(const d of E(e,r)){const l=t.sub(d,s);let n=i(l);if(n&&"next"in n&&(n=yield*n),n&&a.getBlock(l).setPermutation(n instanceof Q?n:n.permutation),n instanceof Y&&H(n)){const m=x(l),b=a.id+"_block"+m;p.structureManager.delete(b),a.extraBlockData[m]=p.structureManager.createFromWorld(b,n.dimension,d,d,{includeEntities:!1,saveMode:J.Memory})}V()&&(yield S.setProgress(f/o)),f++}return a}static*createFromWorld(e,r,i,s={}){const u=t.min(e,r),a=t.from(D(e,r)),o={includeEntities:s.includeEntities??!1,saveMode:J[s.saveAs?"World":"Memory"]},f=yield*this.saveStructs(s.saveAs,e,r,(d,l,n)=>p.structureManager.createFromWorld(d,i,l,n,o));if(f){if(f.volume=I(e,r),f.size=a,s.recordBlocksWithData||s.modifier){let d=0;const l=I(e,r),n=s.modifier??(()=>!0);for(const m of E(e,r)){const b=i.getBlock(m)??(yield*S.loadBlock(m)),g=n(b),h=t.sub(m,u);if(g===!0){if(s.recordBlocksWithData&&H(b)){const y=x(h),_=f.id+"_block"+y;p.structureManager.delete(_),f.extraBlockData[y]=p.structureManager.createFromWorld(_,i,m,m,{includeEntities:!1})}}else f.getBlock(h).setPermutation(g||void 0);V()&&(yield S.setProgress(d/l)),d++}}return f}}static get(e){let r;if(r=p.structureManager.get(e)){const i=new w(e,!1);return i.structure=r,i.volume=r.size.x*r.size.y*r.size.z,i.size=t.from(r.size),i}else if(r=p.structureManager.get(e+"_"+x(t.ZERO))){const i=t.ZERO;for(const a of["x","y","z"]){for(;r=p.structureManager.get(e+"_"+x(i));)i[a]++;i[a]--}const s=i.mul(this.MAX_SIZE).add(p.structureManager.get(e+"_"+x(i)).size),u=new w(e,!0);return Array.from(Object.entries(this.getSubStructs(e,s))).forEach(([a,o])=>u.structures[a]=o.structure),u.volume=s.x*s.y*s.z,u.size=s,u}}*load(e,r,i={}){const s=i.rotation??t.ZERO,u=i.scale??t.ONE,a=this.getBounds(e,i),o=w.getTransformationMatrix(e,i),f=o.invert(),d=i.rotation||i.scale;let l;if(d?l=n=>{const m=n.type.id,b=n.getState("attachment"),g=n.getState("direction"),h=n.getState("door_hinge_bit"),y=n.getState("facing_direction"),_=n.getState("ground_sign_direction"),k=n.getState("open_bit"),W=n.getState("pillar_axis"),$=n.getState("top_slot_bit"),z=n.getState("upside_down_bit"),N=n.getState("weirdo_direction"),C=n.getState("torch_facing_direction"),F=n.getState("lever_direction"),j=n.getState("minecraft:cardinal_direction"),v=c=>{for(const R in c)n=n.withState(R,c[R]);return n};if(z!=null&&k!=null&&g!=null){const c=this.transformMapping(B.trapdoorMap,`${z}_${k}_${g}`,o).split("_");n=v({upside_down_bit:c[0]=="true",open_bit:c[1]=="true",direction:parseInt(c[2])})}else if(N!=null&&z!=null){const c=this.transformMapping(B.stairsMap,`${z}_${N}`,o).split("_");n=v({upside_down_bit:c[0]=="true",weirdo_direction:parseInt(c[1])})}else if(h!=null&&g!=null){const c=this.transformMapping(B.doorMap,`${h}_${g}`,o).split("_");n=v({door_hinge_bit:c[0]=="true",direction:parseInt(c[1])})}else if(b!=null&&g!=null){const c=this.transformMapping(B.bellMap,`${b}_${g}`,o).split("_");n=v({attachment:c[0],direction:parseInt(c[1])})}else if(j!=null){const c=this.transformMapping(B.cardinalDirectionMap,j,o);n=n.withState("minecraft:cardinal_direction",c)}else if(y!=null){const c=this.transformMapping(B.facingDirectionMap,y,o);n=n.withState("facing_direction",parseInt(c))}else if(g!=null){const c=m.includes("powered_repeater")||m.includes("powered_comparator")?B.redstoneMap:B.directionMap,R=this.transformMapping(c,g,o);n=n.withState("direction",parseInt(R))}else if(_!=null){const c=this.transformMapping(B.groundSignDirectionMap,_,o);n=n.withState("ground_sign_direction",parseInt(c))}else if(C!=null){const c=this.transformMapping(B.torchMap,C,o);n=n.withState("torch_facing_direction",c)}else if(F!=null){const c=this.transformMapping(B.leverMap,F,o);n=n.withState("lever_direction",c.replace("0",""))}else if(W!=null){const c=this.transformMapping(B.pillarAxisMap,W+"_0",o);n=n.withState("pillar_axis",c[0])}else if($!=null){const c=this.transformMapping(B.topSlotMap,String($),o);n=n.withState("top_slot_bit",c=="true")}return n}:l=n=>n,Math.abs(s.y)/90%1!=0||s.x||s.z||u.y!=1||Math.abs(u.x)!=1||Math.abs(u.z)!=1||i.mask){let n=0;const m=I(...a);for(const h of E(...a)){const y=t.from(h).add(.5).transform(f).floor(),_=this.getBlock(y);if(V()&&(yield S.setProgress(n/m)),n++,!_?.permutation)continue;let k=r.getBlock(h);!k&&S.inContext()&&(k=yield*S.loadBlock(h)),!(i.mask&&!i.mask.matchesBlock(k))&&(_.nbtStructure&&p.structureManager.place(_.nbtStructure,r,h),k.setPermutation(l(_.permutation)))}const b={location:e,volume:t.sub(this.size,[1,1,1])},g=r.getEntities(b);yield*this.loadStructs(e,r,{includeBlocks:!1}),d&&r.getEntities(b).filter(h=>!g.some(y=>y.id===h.id)).forEach(h=>{let y=h.location,_=t.add(h.getViewDirection(),y);y=t.from(y).sub(e).transform(o).add(e),_=t.from(_).sub(e).transform(o).add(e),h.teleport(y,{dimension:r,facingLocation:_})})}else{yield*this.loadStructs(a[0],r,{rotation:s.y,flip:u});let n=0;const m=Object.keys(this.extraBlockData).length;for(const b in this.extraBlockData){let g=G(b);g=(d?t.add(g,.5).transform(o):t.add(g,e)).floor(),V()&&(yield S.setProgress(n/m)),n++;let h=r.getBlock(g);!h&&S.inContext()&&(h=yield*S.loadBlock(g)),p.structureManager.place(this.extraBlockData[b],r,g),h.setPermutation(l(h.permutation))}}}getSize(){return this.size}getBounds(e,r={}){return w.createBounds(e,t.add(e,this.size).sub(1),r)}getVolume(){return this.volume}*getBlocks(){for(const e of E(t.ZERO,t.sub(this.size,[1,1,1])))yield this.getBlock(e)}ref(){this.refCount++}deref(){--this.refCount<1&&this.delete()}getBlockSingle(e){if(!(e.x<0||e.x>=this.size.x||e.y<0||e.y>=this.size.y||e.z<0||e.z>=this.size.z))return new Z(this,this.extraBlockData,e,this.structure,e)}getBlockMulti(e){if(e.x<0||e.x>=this.size.x||e.y<0||e.y>=this.size.y||e.z<0||e.z>=this.size.z)return;const r={x:Math.floor(e.x/w.MAX_SIZE.x),y:Math.floor(e.y/w.MAX_SIZE.y),z:Math.floor(e.z/w.MAX_SIZE.z)},i=this.structures[x(r)];return new Z(this,this.extraBlockData,e,i,t.sub(e,t.mul(r,w.MAX_SIZE)))}*loadStructs(e,r,i={}){const s=t.from(e),u=new t(0,i.rotation??0,0),a=new t(Math.sign(i.flip?.x??1),1,Math.sign(i.flip?.z??1)),o={rotation:{0:T.None,1:T.Rotate90,2:T.Rotate180,3:T.Rotate270}[rt((u.y??0)/90,4)],mirror:{"1 1":A.None,"-1 1":A.Z,"1 -1":A.X,"-1 -1":A.XZ}[`${a.x} ${a.z}`],includeBlocks:i.includeBlocks??!0};if(this.structure){yield*S.loadArea(e,t.add(e,this.size).sub(1));try{return p.structureManager.place(this.structure,r,s.floor(),o),!1}catch{return!0}}else{const f=this.size,d=P.fromRotationFlipOffset(u,a),l=L(t.ZERO,f.sub(1).floor(),d);let n=!1;for(const[m,b]of Object.entries(this.structures)){const g=G(m).mul(w.MAX_SIZE),h=L(g,g.add(b.size).sub(1),d),y=t.sub(h[0],l[0]).add(s),_=t.sub(h[1],l[0]).add(s);yield*S.loadArea(y,_);try{p.structureManager.place(b,r,y,o)}catch{n=!0;break}}return n}}transformMapping(e,r,i){let s=t.from(e[r]);if(!s)return O.debug(`Can't map state "${r}".`),typeof r=="string"?r:r.toString();s=s.transformDirection(i);let u,a=-1e3;for(const o in e){const f=t.from(e[o]).dot(s);f>a&&(u=o,a=f)}return u}delete(){new K().start(function*(r){for(const i of Object.values(r.extraBlockData))p.structureManager.delete(i),yield;for(const i of Object.values(r.structures))p.structureManager.delete(i),yield;r.structure&&p.structureManager.delete(r.structure),r.size=t.ZERO,r.volume=0,O.debug("deleted structure",r.id)},this)}static createBounds(e,r,i={}){return L(t.ZERO,t.sub(r,e).floor(),w.getTransformationMatrix(e,i))}static getTransformationMatrix(e,r={}){const i=P.fromTranslation(r.offset??t.ZERO);return P.fromRotationFlipOffset(r.rotation??t.ZERO,r.scale??t.ONE).multiply(i).translate(e)}static*saveStructs(e,r,i,s){const u=t.min(r,i),a=D(r,i);if(w.beyondMaxSize(a)){let o=!1;const f=new w(e,!0);for(const[d,l]of Object.entries(this.getSubStructs(f.id,a))){const n=u.add(l.start),m=u.add(l.end);yield*S.loadArea(n,m);try{p.structureManager.delete(l.name),l.structure=s(l.name,u.add(l.start),u.add(l.end)),f.structures[d]=l.structure}catch{o=!0;break}}if(o){Object.values(f.structures).forEach(d=>p.structureManager.delete(d));return}else return f}else{const o=new w(e,!1);yield*S.loadArea(r,i);try{return p.structureManager.delete(o.id),o.structure=s(o.id,r,i),o}catch{return}}}static beyondMaxSize(e){return e.x>w.MAX_SIZE.x||e.y>w.MAX_SIZE.y||e.z>w.MAX_SIZE.z}static getSubStructs(e,r){const i={};for(let s=0;s<r.z;s+=this.MAX_SIZE.z)for(let u=0;u<r.y;u+=this.MAX_SIZE.y)for(let a=0;a<r.x;a+=this.MAX_SIZE.x){const o=new t(a,u,s),f=t.min(o.add(this.MAX_SIZE).sub(1),r.sub(1)),d=`${a/this.MAX_SIZE.x}_${u/this.MAX_SIZE.y}_${s/this.MAX_SIZE.z}`;i[d]={structure:p.structureManager.get(e+"_"+d),name:e+"_"+d,start:o,end:f}}return i}};w.MAX_SIZE=new t(64,256,64);let q=w;const M=class M{constructor(e,r,i,s,u){this.buffer=e,this.x=Math.floor(i.x),this.y=Math.floor(i.y),this.z=Math.floor(i.z),this.bufferBlockNBT=r,this.bufferStructure=s,this.bufferStructureLocation=u}get permutation(){return this.bufferStructure.getBlockPermutation(this.bufferStructureLocation)}get location(){return{x:this.x,y:this.y,z:this.z}}get nbtStructure(){return this.bufferBlockNBT[x(this.location)]}get type(){return this.permutation.type}get typeId(){return this.permutation.type.id}get isAir(){return this.permutation.matches(M.AIR)}get isLiquid(){return M.LIQUIDS.includes(this.permutation.type.id)}get isWaterlogged(){return this.bufferStructure.getIsWaterlogged(this.bufferStructureLocation)}above(e){return this.buffer.getBlock({x:this.x,y:this.y+(e??1),z:this.z})}below(e){return this.buffer.getBlock({x:this.x,y:this.y-(e??1),z:this.z})}north(e){return this.buffer.getBlock({x:this.x,y:this.y,z:this.z-(e??1)})}south(e){return this.buffer.getBlock({x:this.x,y:this.y,z:this.z+(e??1)})}east(e){return this.buffer.getBlock({x:this.x+(e??1),y:this.y,z:this.z})}west(e){return this.buffer.getBlock({x:this.x-(e??1),y:this.y,z:this.z})}offset(e){return this.buffer.getBlock({x:this.x+e.x,y:this.y+e.y,z:this.z+e.z})}bottomCenter(){return{x:this.x+.5,y:this.y,z:this.z+.5}}center(){return{x:this.x+.5,y:this.y+.5,z:this.z+.5}}getTags(){return this.permutation.getTags()}hasTag(e){return this.permutation.hasTag(e)}matches(e,r){return this.permutation.matches(e,r)}setPermutation(e){let r;e?.type.id!==this.permutation?.type.id&&(r=x(this.location))in this.bufferBlockNBT&&(p.structureManager.delete(this.bufferBlockNBT[r]),delete this.bufferBlockNBT[r]),this.bufferStructure.setBlockPermutation(this.bufferStructureLocation,e),this.buffer.savedToWorld&&!M.structureSaveQueues.has(this.bufferStructure)&&M.structureSaveQueues.set(this.bufferStructure,tt.run(()=>{M.structureSaveQueues.delete(this.bufferStructure),this.bufferStructure.saveToWorld()}))}setType(e){this.setPermutation(Q.resolve(typeof e=="string"?e:e.id))}};M.AIR="minecraft:air",M.LIQUIDS=["minecraft:water","minecraft:lava"],M.structureSaveQueues=new WeakMap;let Z=M;function H(X){return et(X)||X.typeId.match(/^minecraft:.*trapdoor$/)}const B={topSlotMap:{false:new t(0,1,0),true:new t(0,-1,0)},redstoneMap:{0:new t(0,0,-1),1:new t(1,0,0),2:new t(0,0,1),3:new t(-1,0,0)},directionMap:{0:new t(1,0,0),1:new t(0,0,1),2:new t(-1,0,0),3:new t(0,0,-1)},facingDirectionMap:{0:new t(0,-1,0),1:new t(0,1,0),2:new t(0,0,-1),3:new t(0,0,1),4:new t(-1,0,0),5:new t(1,0,0)},cardinalDirectionMap:{north:new t(0,0,-1),south:new t(0,0,1),west:new t(-1,0,0),east:new t(1,0,0)},pillarAxisMap:{x_0:new t(1,0,0),y_0:new t(0,1,0),z_0:new t(0,0,1),x_1:new t(-1,0,0),y_1:new t(0,-1,0),z_1:new t(0,0,-1)},groundSignDirectionMap:{0:new t(0,0,1),1:new t(0,0,1).rotate(1/16*360,"y"),2:new t(0,0,1).rotate(2/16*360,"y"),3:new t(0,0,1).rotate(3/16*360,"y"),4:new t(0,0,1).rotate(4/16*360,"y"),5:new t(0,0,1).rotate(5/16*360,"y"),6:new t(0,0,1).rotate(6/16*360,"y"),7:new t(0,0,1).rotate(7/16*360,"y"),8:new t(0,0,1).rotate(8/16*360,"y"),9:new t(0,0,1).rotate(9/16*360,"y"),10:new t(0,0,1).rotate(10/16*360,"y"),11:new t(0,0,1).rotate(11/16*360,"y"),12:new t(0,0,1).rotate(12/16*360,"y"),13:new t(0,0,1).rotate(13/16*360,"y"),14:new t(0,0,1).rotate(14/16*360,"y"),15:new t(0,0,1).rotate(15/16*360,"y")},stairsMap:{false_0:new t(-1,1,0),false_1:new t(1,1,0),false_2:new t(0,1,-1),false_3:new t(0,1,1),true_0:new t(-1,-1,0),true_1:new t(1,-1,0),true_2:new t(0,-1,-1),true_3:new t(0,-1,1)},torchMap:{north:new t(0,0,1),east:new t(-1,0,0),south:new t(0,0,-1),west:new t(1,0,0),top:new t(0,1,0)},leverMap:{north:new t(0,0,1),east:new t(-1,0,0),south:new t(0,0,-1),west:new t(1,0,0),up_north_south:new t(0,1,.5),up_north_south0:new t(0,1,-.5),up_east_west:new t(.5,1,0),up_east_west0:new t(-.5,1,0),down_north_south:new t(0,-1,.5),down_north_south0:new t(0,-1,-.5),down_east_west:new t(.5,-1,0),down_east_west0:new t(-.5,-1,0)},doorMap:{false_0:new t(1,0,.5),false_1:new t(-.5,0,1),false_2:new t(-1,0,-.5),false_3:new t(.5,0,-1),true_0:new t(1,0,-.5),true_1:new t(.5,0,1),true_2:new t(-1,0,.5),true_3:new t(-.5,0,-1)},bellMap:{standing_0:new t(1,.5,0),standing_1:new t(0,.5,1),standing_2:new t(-1,.5,0),standing_3:new t(0,.5,-1),side_0:new t(1,0,0),side_1:new t(0,0,1),side_2:new t(-1,0,0),side_3:new t(0,0,-1),hanging_0:new t(1,-.5,0),hanging_1:new t(0,-.5,1),hanging_2:new t(-1,-.5,0),hanging_3:new t(0,-.5,-1)},trapdoorMap:{false_false_0:new t(-.5,1,0),false_false_1:new t(.5,1,0),false_false_2:new t(0,1,-.5),false_false_3:new t(0,1,.5),true_false_0:new t(-.5,-1,0),true_false_1:new t(.5,-1,0),true_false_2:new t(0,-1,-.5),true_false_3:new t(0,-1,.5),false_true_0:new t(-1,.5,0),false_true_1:new t(1,.5,0),false_true_2:new t(0,.5,-1),false_true_3:new t(0,.5,1),true_true_0:new t(-1,-.5,0),true_true_1:new t(1,-.5,0),true_true_2:new t(0,-.5,-1),true_true_3:new t(0,-.5,1)}};export{q as RegionBuffer};
