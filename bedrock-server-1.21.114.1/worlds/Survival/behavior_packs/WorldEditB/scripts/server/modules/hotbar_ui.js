import{ItemLockMode as v,ItemStack as T,system as I}from"@minecraft/server";import{Server as c}from"library/Minecraft.js";import{PlayerUtil as u}from"./player_util.js";import{print as f}from"server/util.js";class b{constructor(t){this.form=t;this.items=[];this.tick=t.tick,this.entered=t.entered,this.exiting=t.exiting,this.cancel=t.cancel}build(t,e){const i=o=>o instanceof Function?o(t,e):o;this.items=[],this.title=i(this.form.title);const n=i(this.form.items);for(let o=0;o<8;o++){const r=n[o]??{item:"wedit:blank"};this.items.push({name:i(r.item),data:i(r.dataValue??0),action:r.action})}return this.items.push({name:"wedit:cancel_button",data:0,action:(o,r)=>{o.goto(null),this.cancel(o,r)}}),null}enter(t,e){u.stashHotbar(t),this.build(e,t);const i=this.title,n=this.items;f(i,t);const o=c.player.getInventory(t);for(let s=0;s<n.length;s++){const a=new T(n[s].name);a.lockMode=v.slot,o.setItem(s,a)}const r=s=>{if(s.source!=t)return;s.cancel=!0;const a=t.selectedSlotIndex;n[a].name!="wedit:blank"&&I.run(()=>n[a].action?.(e,t))};c.prependListener("itemUseBefore",r);const d=()=>{this.tick?.(e,t)};c.prependListener("tick",d);const l=e;l.setData("__useEvent__",r),l.setData("__tickEvent__",d),this.entered?.(e,t)}exit(t,e){this.exiting?.(e,t);const i=e;c.off("itemUseBefore",i.getData("__useEvent__")),c.off("tick",i.getData("__tickEvent__")),u.restoreHotbar(t)}}class m{constructor(t,e){this.player=t;this.stack=[];this.data={};this.base=e}getData(t){return this.base?.getData(t)??this.data[t]}setData(t,e){this.base?.setData(t,e),this.data[t]=e}goto(t){t&&this.stack.push(t);try{this.currentForm=p.goto(t,this.player,this)}catch(e){if(!this.currentForm&&this.base)this.base.goto(t);else throw e}}back(){this.stack.pop(),this.stack.length?this.goto(this.stack.pop()):this.base?.goto(this.base.currentMenu)}returnto(t){let e;for(;e=this.stack.pop();)if(e===t){this.goto(t);return}this.goto(void 0),this.base?.returnto(t)}confirm(){throw"No 'confirm' action in a hotbar UI context."}error(t){typeof t=="string"?t={rawtext:[{text:"\xA7c"},{translate:t},{text:"\xA7r"}]}:t&&(t={rawtext:[{text:"\xA7c"},...t.rawtext,{text:"\xA7r"}]}),f(t,this.player,!0)}get currentMenu(){return this.stack[this.stack.length-1]}}class U{constructor(){this.forms=new Map;this.active=new Map}register(t,e){this.forms.set(t,new b(e))}show(t,e,i){if(this.displayingUI(e))return!0;const n=new m(e);return Object.entries(i??{}).forEach(o=>n.setData(o[0],o[1])),n.goto(t),!1}goto(t,e,i){if(i instanceof m||(i=new m(e,i)),this.active.has(e)&&(this.active.get(e).exit(e,i),this.active.delete(e)),t)if(this.forms.has(t)){const n=this.forms.get(t);return this.active.set(e,n),n.enter(e,i),n}else throw new TypeError(`Menu "${t}" has not been registered!`);else return}displayingUI(t,e){if(this.active.has(t)){if(e){const i=this.active.get(t);for(const n of this.forms.values())if(n==i)return!0;return!1}return!0}return!1}}const p=new U;export{p as HotbarUI};
