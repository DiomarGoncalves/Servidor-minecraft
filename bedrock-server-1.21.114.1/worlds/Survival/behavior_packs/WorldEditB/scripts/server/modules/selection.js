import{regionBounds as u,regionVolume as _,Vector as i}from"library/Minecraft.js";import{SphereShape as m}from"../shapes/sphere.js";import{CuboidShape as b}from"../shapes/cuboid.js";import{CylinderShape as f}from"../shapes/cylinder.js";import{getWorldHeightLimits as g}from"../util.js";import y from"config.js";import{ConvexShape as S}from"server/shapes/convex.js";const D=["cuboid","extend","sphere","cylinder","convex","volume"];class M{constructor(h){this.player=h}}class x extends M{constructor(){super(...arguments);this.visible=y.drawOutlines;this._mode="cuboid";this._points=[]}get isEmpty(){let t=0;for(const e of this._points)e&&t++;return t===0||t===1}get isCuboid(){return this._mode=="cuboid"||this._mode=="extend"}get mode(){return this._mode}set mode(t){if(this._mode==t)return;const e=this.isCuboid;this._mode=t,(!this.isCuboid||e!=this.isCuboid)&&this.clear()}get points(){return this._points.map(t=>t.clone())}set(t,e){if(t>0&&this._points.length==0&&this._mode!="cuboid")throw"worldedit.selection.noPrimary";if(this._points.length<=t&&(this._points.length=t+1),t==0&&this._mode=="convex")this._points=[e];else if(t==0&&this._mode!="cuboid")this._points=[e,e.offset(0,0,0)];else if(this._mode=="cuboid")this._points[t]=e,this._mode!="cuboid"&&(this._points.length=1);else if(this._mode=="extend")this._points[0]=i.min(this._points[0],this._points[1]).min(e).floor(),this._points[1]=i.max(this._points[0],this._points[1]).max(e).floor();else if(this._mode=="sphere"){const o=Math.round(i.sub(e,this._points[0]).length);this._points[1]=new i(o,0,0).add(this._points[0]).floor()}else if(this._mode=="cylinder"){const o=i.sub(this._points[1],this._points[0]).mul([1,0,1]),a=i.sub(e,this._points[0]).mul([1,0,1]),c=i.min(this._points[0],this._points[1]).min(e),l=i.max(this._points[0],this._points[1]).max(e),d=Math.round(Math.max(a.length,o.length));this._points[1]=new i(d,0,0).add(this._points[0]).floor(),this._points[0].y=c.y,this._points[1].y=l.y}else this._mode=="convex"&&(this._points[1]?this._points.push(e):this._points[1]=e);const[s,r]=g(this.player.dimension);this._points.forEach(o=>o.y=Math.min(Math.max(o.y,s),r)),this.updateShape()}clear(){this._points.length&&(this._points=[],this.updateShape())}getShape(){return this._shape}*getBlocks(t){if(this.isEmpty)return;const[e,s]=this.getShape();yield*e.getBlocks(s,t)}getBlockCount(){if(this.isEmpty)return 0;if(this.isCuboid)return _(this._points[0],this._points[1]);if(this._mode=="sphere"){const t=i.sub(this._points[1],this._points[0]).length;return Math.round(4/3*Math.PI*Math.pow(t,3))}else if(this._mode=="cylinder"){const t=i.sub(this._points[1],this._points[0]),e=Math.abs(t.y)+1,s=Math.round(t.mul([1,0,1]).length)+.5;return Math.ceil(Math.pow(s,2)*Math.PI*e)}}getRange(){const[t,e]=this.getShape();if(t)return t.getRegion(e)}updateShape(){if(this.isEmpty)this._shape=void 0;else if(this.isCuboid){const[t,e]=u(this._points),s=i.sub(e,t).add(1);this._shape=[new b(s.x,s.y,s.z),i.from(t)]}else if(this._mode=="sphere"){const t=this._points[0],e=i.sub(this._points[1],this._points[0]).length;this._shape=[new m(e),t]}else if(this._mode=="cylinder"){const t=this._points[0],e=i.sub(this._points[1],this._points[0]),s=Math.abs(e.y)+1;this._shape=[new f(s,Math.round(e.mul([1,0,1]).length)),t.offset(0,s/2,0)]}else this._mode=="convex"&&(this._shape=this._points.length>=4?[new S(this._points),i.ZERO]:void 0,this._shape&&(this._shape[0].drawCurve=!0))}}let p=x;function F(n){return new p(n)}function H(n){p=n}export{M as Selection,F as createSelectionForPlayer,D as selectionModes,H as setSelectionClass};
