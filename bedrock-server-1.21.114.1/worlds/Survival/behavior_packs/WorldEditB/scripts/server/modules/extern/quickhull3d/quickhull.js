import{VertexList as b}from"./vertexlist.js";import{Vertex as A}from"./vertex.js";import{Face as x,Mark as u}from"./face.js";import{Vector as m}from"library/Minecraft.js";var T=(e=>(e[e.NonConvexWrtLargerFace=0]="NonConvexWrtLargerFace",e[e.NonConvex=1]="NonConvex",e))(T||{});class D{}class O{constructor(t){if(!Array.isArray(t))throw TypeError("input is not a valid array");if(t.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.faces=[],this.newFaces=[],this.claimed=new b,this.unclaimed=new b,this.vertices=[];for(let e=0;e<t.length;e+=1)this.vertices.push(new A(t[e],e));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(t,e){t.face=e,e.outside?this.claimed.insertBefore(e.outside,t):this.claimed.add(t),e.outside=t}removeVertexFromFace(t,e){t===e.outside&&(t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.claimed.remove(t)}removeAllVerticesFromFace(t){if(t.outside){let e=t.outside;for(;e.next&&e.next.face===t;)e=e.next;return this.claimed.removeChain(t.outside,e),e.next=null,t.outside}}deleteFaceVertices(t,e){const i=this.removeAllVerticesFromFace(t);if(i)if(!e)this.unclaimed.addAll(i);else{let s;for(let o=i;o;o=s)s=o.next,e.distanceToPlane(o.point)>this.tolerance?this.addVertexToFace(o,e):this.unclaimed.add(o)}}resolveUnclaimedPoints(t){let e=this.unclaimed.first();for(let i=e;i;i=e){e=i.next;let s=this.tolerance,o;for(let c=0;c<t.length;c+=1){const r=t[c];if(r.mark===u.Visible){const d=r.distanceToPlane(i.point);if(d>s&&(s=d,o=r),s>1e3*this.tolerance)break}}o&&this.addVertexToFace(i,o)}}allPointsBelongToPlane(t,e,i){const s=E(t.point,e.point,i.point),o=s.dot(t.point);for(const c of this.vertices){const r=c.point.dot(s);if(Math.abs(r-o)>this.tolerance)return!1}return!0}computeTetrahedronExtremes(){const t=m.ZERO,e=m.ZERO,i={},s={};for(const a of m.AXES)i[a]=s[a]=this.vertices[0];for(const a of m.AXES)t[a]=e[a]=this.vertices[0].point[a];for(let a=1;a<this.vertices.length;a+=1){const l=this.vertices[a],p=l.point;for(const f of m.AXES)p[f]<t[f]&&(t[f]=p[f],i[f]=l);for(const f of m.AXES)p[f]>e[f]&&(e[f]=p[f],s[f]=l)}this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z)));let o=0,c="x";for(const a of m.AXES){const l=s[a].point[a]-i[a].point[a];l>o&&(o=l,c=a)}const r=i[c],d=s[c];let n,h;o=0;for(let a=0;a<this.vertices.length;a+=1){const l=this.vertices[a];if(l!==r&&l!==d){const p=w(l.point,r.point,d.point);p>o&&(o=p,n=l)}}const V=E(r.point,d.point,n.point),F=r.point.dot(V);o=-1;for(let a=0;a<this.vertices.length;a+=1){const l=this.vertices[a];if(l!==r&&l!==d&&l!==n){const p=Math.abs(V.dot(l.point)-F);p>o&&(o=p,h=l)}}return[r,d,n,h]}createInitialSimplex(t,e,i,s){const o=E(t.point,e.point,i.point),c=t.point.dot(o),r=[];if(s.point.dot(o)-c<0){r.push(x.createTriangle(t,e,i),x.createTriangle(s,e,t),x.createTriangle(s,i,e),x.createTriangle(s,t,i));for(let n=0;n<3;n+=1){const h=(n+1)%3;r[n+1].getEdge(2).setOpposite(r[0].getEdge(h)),r[n+1].getEdge(1).setOpposite(r[h+1].getEdge(0))}}else{r.push(x.createTriangle(t,i,e),x.createTriangle(s,t,e),x.createTriangle(s,e,i),x.createTriangle(s,i,t));for(let n=0;n<3;n+=1){const h=(n+1)%3;r[n+1].getEdge(2).setOpposite(r[0].getEdge((3-n)%3)),r[n+1].getEdge(0).setOpposite(r[h+1].getEdge(1))}}for(let n=0;n<4;n+=1)this.faces.push(r[n]);const d=this.vertices;for(let n=0;n<d.length;n+=1){const h=d[n];if(h!==t&&h!==e&&h!==i&&h!==s){let V=this.tolerance,F;for(let a=0;a<4;a+=1){const l=r[a].distanceToPlane(h.point);l>V&&(V=l,F=r[a])}F&&this.addVertexToFace(h,F)}}}reindexFaceAndVertices(){const t=[];for(let e=0;e<this.faces.length;e+=1){const i=this.faces[e];i.mark===u.Visible&&t.push(i)}this.faces=t}collectFaces(t){const e=[];for(let i=0;i<this.faces.length;i+=1){if(this.faces[i].mark!==u.Visible)throw Error("attempt to include a destroyed face in the hull");const s=this.faces[i].collectIndices();if(t)e.push(s);else for(let o=0;o<s.length-2;o+=1)e.push([s[0],s[o+1],s[o+2]])}return e}nextVertexToAdd(){if(!this.claimed.isEmpty()){let t,e,i=0;const s=this.claimed.first().face;for(e=s.outside;e&&e.face===s;e=e.next){const o=s.distanceToPlane(e.point);o>i&&(i=o,t=e)}return t}}computeHorizon(t,e,i,s){this.deleteFaceVertices(i),i.mark=u.Deleted;let o;e?o=e.next:o=e=i.getEdge(0);do{const c=o.opposite,r=c.face;r.mark===u.Visible&&(r.distanceToPlane(t)>this.tolerance?this.computeHorizon(t,c,r,s):s.push(o)),o=o.next}while(o!==e)}addAdjoiningFace(t,e){const i=x.createTriangle(t,e.tail(),e.head());return this.faces.push(i),i.getEdge(-1).setOpposite(e.opposite),i.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let i,s;for(let o=0;o<e.length;o+=1){const c=e[o],r=this.addAdjoiningFace(t,c);i?r.next.setOpposite(s):i=r,this.newFaces.push(r.face),s=r}i.next.setOpposite(s)}oppositeFaceDistance(t){return t.face.distanceToPlane(t.opposite.face.centroid)}doAdjacentMerge(t,e){let i=t.edge,s=!0,o=0;do{if(o>=t.nVertices)throw Error("merge recursion limit exceeded");const c=i.opposite.face;let r=!1;if(e===1?(this.oppositeFaceDistance(i)>-this.tolerance||this.oppositeFaceDistance(i.opposite)>-this.tolerance)&&(r=!0):t.area>c.area?this.oppositeFaceDistance(i)>-this.tolerance?r=!0:this.oppositeFaceDistance(i.opposite)>-this.tolerance&&(s=!1):this.oppositeFaceDistance(i.opposite)>-this.tolerance?r=!0:this.oppositeFaceDistance(i)>-this.tolerance&&(s=!1),r){const d=t.mergeAdjacentFaces(i,[]);for(let n=0;n<d.length;n+=1)this.deleteFaceVertices(d[n],t);return!0}i=i.next,o+=1}while(i!==t.edge);return s||(t.mark=u.NonConvex),!1}addVertexToHull(t){const e=[];this.unclaimed.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e);for(let i=0;i<this.newFaces.length;i+=1){const s=this.newFaces[i];if(s.mark===u.Visible)for(;this.doAdjacentMerge(s,0););}for(let i=0;i<this.newFaces.length;i+=1){const s=this.newFaces[i];if(s.mark===u.NonConvex)for(s.mark=u.Visible;this.doAdjacentMerge(s,0););}this.resolveUnclaimedPoints(this.newFaces)}build(){let t;const[e,i,s,o]=this.computeTetrahedronExtremes();for(this.createInitialSimplex(e,i,s,o);t=this.nextVertexToAdd();)this.addVertexToHull(t);return this.reindexFaceAndVertices(),this}}function j(g,t,e,i=0){for(let s=0;s<e.length;s++){const o=e[s],c=t[o[0]],r=t[o[1]],d=t[o[2]],n=E(c,r,d),h=g.sub(c).add(n.mul(i));if(n.dot(h)>0)return!1}return!0}function E(g,t,e){const i=t.sub(g),s=e.sub(g);return i.cross(s)}function w(g,t,e){const i=m.sub(e,t),o=m.sub(g,t).cross(i).lengthSqr,c=i.lengthSqr;if(c===0)throw Error("a and b are the same point");return o/c}export{O as QuickHull,D as QuickHullOptions,j as isPointInsideHull};
