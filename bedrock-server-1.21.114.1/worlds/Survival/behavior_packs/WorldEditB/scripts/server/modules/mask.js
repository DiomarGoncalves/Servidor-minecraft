import{BlockPermutation as E,Direction as y}from"@minecraft/server";import{Vector as l,whenReady as S}from"library/Minecraft.js";import{Token as D}from"./extern/tokenizr.js";import{tokenize as F,throwTokenError as f,mergeTokens as L,parseBlock as $,processOps as w,parseBlockStates as z,blockPermutation2ParsedBlock as q,parsedBlock2BlockPermutation as R}from"./block_parsing.js";import{iterateBlockPermutations as V}from"server/util.js";class P{constructor(n=""){this.stringObj="";this.context={};n&&S(()=>{const e=P.parseArgs([n]).result;this.condition=e.condition,this.stringObj=e.stringObj})}withContext(n){const e=this.clone();return e.context.placePosition=n.getPlacementPosition().add(.5),e}matchesBlock(n){return this.empty()?!0:this.condition.matchesBlock(n,this.context)}clear(){this.condition=null,this.stringObj="",this.simpleCache=void 0}empty(){return this.condition==null}addBlock(n){this.condition==null&&(this.condition=new b(null));const e=q(n);this.condition.nodes.push(new x(null,e)),this.stringObj&&(this.stringObj+=","),this.stringObj+=e.id.replace("minecraft:",""),e.states.size&&(this.stringObj+=`[${[...e.states].map(([t,s])=>`${t}=${s}`).join(",")}]`),this.simpleCache=void 0}intersect(n){let e;n.condition?this.condition?(e=new T(null),e.nodes=[this.condition,n.condition]):e=n.condition:e=this.condition;const t=new P;return t.condition=e,t}getBlockSummary(){if(!this.condition||!(this.condition instanceof b))return"";let n="",e=0;for(const t of this.condition.nodes){let s=t.block.id.replace("minecraft:","");for(const o of t.block.states){const i=o[1];if(typeof i=="string"&&i!="x"&&i!="y"&&i!="z"){s+=`(${i})`;break}}n+=s,e<this.condition.nodes.length-1&&(n+=", "),e++}return n}toJSON(){return this.stringObj}isSimple(){const n=this.condition,e=n?.nodes[0];return!n||n instanceof x||n instanceof b&&n.nodes.every(t=>t instanceof x)||n instanceof U&&(e instanceof x||e instanceof b&&e.nodes.every(t=>t instanceof x))}getSimpleBlockFilter(){if(this.simpleCache)return this.simpleCache;const n=(i,h,m)=>{const d=R(i);if(i.states!=null){const u=Array.from(i.states.entries());for(const c of V(i.id))u.every(([C,k])=>c[C]===k)&&m.push(E.resolve(i.id,c))}else h.push(d.type.id)},e=[],t=[],s=[],o=[];if(this.simpleCache={},this.condition instanceof x)n(this.condition.block,e,s);else if(this.condition instanceof b)this.condition.nodes.forEach(i=>n(i.block,e,s));else if(this.condition instanceof U){const i=this.condition.nodes[0];i instanceof x?n(i.block,t,o):i instanceof b&&i.nodes.forEach(h=>n(h.block,t,o))}return e.length&&(this.simpleCache.includeTypes=e),t.length&&(this.simpleCache.excludeTypes=t),s.length&&(this.simpleCache.includePermutations=s),o.length&&(this.simpleCache.excludePermutations=o),this.simpleCache}clone(){const n=new P;return n.condition=this.condition,n.stringObj=this.stringObj,n}toString(){return`[mask: ${this.stringObj}]`}static parseArgs(n,e=0){const t=n[e];if(!t)return{result:new P,argIndex:e+1};const s=F(t);let o;function i(d){const u=[],c=[],C=s.curr();function k(){return L(o,s.curr(),t)}for(;o=s.next();)if(o.type=="id")c.push(new x(k(),$(s,t,!1,!0)));else if(o.value==",")w(c,u,new b(o));else if(o.type=="space")w(c,u,new T(o));else if(o.value=="!")w(c,u,new U(o));else if(o.type=="bracket")if(o.value=="<")w(c,u,new O(o,0,1,0));else if(o.value==">")w(c,u,new O(o,0,-1,0));else if(o.value=="(")c.push(i(!0));else if(o.value==")")if(!d)f(o);else{w(c,u);break}else f(o);else if(o.value=="#"){const a=s.next();if(a.value=="slope"){let r=s.next();r.value!="["&&f(r),r=s.next(),r.type!="number"&&f(r);const g=r.value;r=s.next(),r.value!=":"&&f(r),r=s.next(),r.type!="number"&&f(r);const N=r.value;r=s.next(),r.value!="]"&&f(r),c.push(new M(k(),g,N))}else if(a.value=="existing")c.push(new J(k()));else if(a.value=="surface"||a.value=="exposed")c.push(new W(k()));else if(a.value=="shadow")c.push(new A(k()));else if(a.value=="#"){const r=s.next();r.type!="id"&&f(r),c.push(new X(k(),r.value))}else f(a)}else if(o.value=="%"){const a=s.next();a.type!="number"&&f(a),c.push(new Z(k(),a.value/100))}else if(o.value=="^"){let a,r=!1,g=s.next();g.value=="="?(r=!0,g=s.next(),g.value!="["&&f(g),a=z(s)):g.value=="["?a=z(s):f(g),c.push(new I(k(),a,r))}else o.type=="EOF"?d?f(o):w(c,u):f(o);if(c.length>1)f(c.slice(-1)[0].token);else if(!c.length)f(C);else if(u.length){const a=u.slice(-1)[0];f(a instanceof D?a:a.token)}return c[0]}let h;try{h=i(!1),h.postProcess()}catch(d){throw d.pos!=null?{isSyntaxError:!0,idx:e,start:d.pos,end:d.pos+1,stack:d.stack}:d}const m=new P;return m.stringObj=n[e],m.condition=h,{result:m,argIndex:e+1}}}class p{constructor(n){this.token=n;this.nodes=[]}postProcess(){}}class x extends p{constructor(e,t){super(e);this.block=t;this.prec=-1;this.opCount=0;this.states=Object.fromEntries(t.states?.entries()??[])}matchesBlock(e){return e.permutation.matches(this.block.id,this.states)}}class I extends p{constructor(e,t,s){super(e);this.states=t;this.strict=s;this.prec=-1;this.opCount=0}matchesBlock(e){const t=e.permutation.getAllStates();let s=0;for(const[o,i]of this.states.entries())(this.strict&&o in t&&i==t[o]||!this.strict&&(!(o in t)||i==t[o]))&&s++;return s==this.states.size}}class W extends p{constructor(){super(...arguments);this.prec=-1;this.opCount=0}matchesBlock(e){const t=l.from(e.location),s=e.dimension,o=i=>s.getBlock(i).isAir;return!o(t)&&(o(t.offset(0,1,0))||o(t.offset(0,-1,0))||o(t.offset(-1,0,0))||o(t.offset(1,0,0))||o(t.offset(0,0,-1))||o(t.offset(0,0,1)))}}class J extends p{constructor(){super(...arguments);this.prec=-1;this.opCount=0}matchesBlock(e){return!e.isAir}}const j=class j extends p{constructor(){super(...arguments);this.prec=-1;this.opCount=0}matchesBlock(e,t){const s=t.placePosition,o=l.sub(l.add(e.location,[.5,.5,.5]),s);for(const i of j.testFaces){if(i.dot(o)>0)continue;const h=l.add(e.location,i).add(.5),m=l.sub(h,s),d=e.dimension.getBlockFromRay(s,m,{includePassableBlocks:!1,includeLiquidBlocks:!1});if(!d)return!1;const u=l.add(d.block,d.faceLocation);if(l.sub(u,s).length>m.length+.01||l.equals(d.block,e.location))return!1}return!0}};j.testFaces=[l.from(y.Up).mul(.5),l.from(y.Down).mul(.5),l.from(y.North).mul(.5),l.from(y.South).mul(.5),l.from(y.East).mul(.5),l.from(y.West).mul(.5)];let A=j;const B=class B extends p{constructor(e,t,s){super(e);this.lowerAngle=t;this.upperAngle=s;this.prec=-1;this.opCount=0}matchesBlock(e){const t={};for(const[m,d]of Object.entries(B.testOffsets)){const u=l.add(e,d).add(.5);let c=e.dimension.getBlock(u);for(;c?.isSolid;)c=c.above(),u.y++;const C=e.dimension.getBlockFromRay(u,l.DOWN,{includePassableBlocks:!1,includeLiquidBlocks:!1});C&&(t[m]=C.block.y+C.faceLocation.y)}const s=B.testDistance*2,o=Math.abs(t["+z"]-t["-z"])/s,i=Math.abs(t["+x"]-t["-x"])/s,h=90-Math.atan(1/Math.sqrt(o**2+i**2))*(180/Math.PI);return h>=this.lowerAngle&&h<=this.upperAngle}};B.testDistance=2,B.testOffsets={"-z":l.from(y.North).mul(B.testDistance),"+z":l.from(y.South).mul(B.testDistance),"+x":l.from(y.East).mul(B.testDistance),"-x":l.from(y.West).mul(B.testDistance)};let M=B;class X extends p{constructor(e,t){super(e);this.tag=t;this.prec=-1;this.opCount=0}matchesBlock(e){return e.hasTag(this.tag)}}class Z extends p{constructor(e,t){super(e);this.percent=t;this.prec=-1;this.opCount=0}matchesBlock(){return Math.random()<this.percent}}class b extends p{constructor(){super(...arguments);this.prec=3;this.opCount=2}matchesBlock(e,t){for(const s of this.nodes)if(s.matchesBlock(e,t))return!0;return!1}postProcess(){super.postProcess();const e=this.nodes;for(this.nodes=[];e.length;){const t=e.shift();if(t instanceof b){const s=t.nodes.reverse();for(const o of s)e.unshift(o)}else this.nodes.push(t),t.postProcess()}}}class T extends p{constructor(){super(...arguments);this.prec=1;this.opCount=2}matchesBlock(e,t){for(const s of this.nodes)if(!s.matchesBlock(e,t))return!1;return!0}postProcess(){super.postProcess();const e=this.nodes;for(this.nodes=[];e.length;){const t=e.shift();if(t instanceof T){const s=t.nodes.reverse();for(const o of s)e.unshift(o)}else this.nodes.push(t),t.postProcess()}}}class U extends p{constructor(){super(...arguments);this.prec=2;this.opCount=1}matchesBlock(e,t){return!this.nodes[0].matchesBlock(e,t)}}class O extends p{constructor(e,t,s,o){super(e);this.x=t;this.y=s;this.z=o;this.prec=2;this.opCount=1}matchesBlock(e,t){const s=e.location;return this.nodes[0].matchesBlock(e.dimension.getBlock({x:s.x+this.x,y:s.y+this.y,z:s.z+this.z}),t)}postProcess(){for(;this.nodes[0]instanceof O;)this.x+=this.nodes[0].x,this.y+=this.nodes[0].y,this.z+=this.nodes[0].z,this.nodes=this.nodes[0].nodes}}export{P as Mask};
